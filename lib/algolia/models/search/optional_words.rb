# frozen_string_literal: true

# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

require "date"
require "time"

module Algolia
  module Search
    # Words that should be considered optional when found in the query.  By default, records must match all words in the search query to be included in the search results. Adding optional words can help to increase the number of search results by running an additional search query that doesn't include the optional words. For example, if the search query is \"action video\" and \"video\" is an optional word, the search engine runs two queries. One for \"action video\" and one for \"action\". Records that match all words are ranked higher.  For a search query with 4 or more words **and** all its words are optional, the number of matched words required for a record to be included in the search results increases for every 1,000 records:  - If `optionalWords` has less than 10 words, the required number of matched words increases by 1:   results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 2 matched words. - If `optionalWords` has 10 or more words, the number of required matched words increases by the number of optional words divided by 5 (rounded down).   For example, with 18 optional words: results 1 to 1,000 require 1 matched word, results 1,001 to 2000 need 4 matched words.  For more information, see [Optional words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/empty-or-insufficient-results/#creating-a-list-of-optional-words).
    module OptionalWords
      class << self
      # List of class defined in oneOf (OpenAPI v3)
        def openapi_one_of
          [
            :"Array<String>",
            :"String"
          ]
        end

        # Builds the object
        # @param [Mixed] Data to be matched against the list of oneOf items
        # @return [Object] Returns the model or the data itself
        def build(data)
          # Go through the list of oneOf items and attempt to identify the appropriate one.
          # Note:
          # - We do not attempt to check whether exactly one item matches.
          # - No advanced validation of types in some cases (e.g. "x: { type: string }" will happily match { x: 123 })
          #   due to the way the deserialization is made in the base_object template (it just casts without verifying).
          # - TODO: scalar values are de facto behaving as if they were nullable.
          # - TODO: logging when debugging is set.
          openapi_one_of.each do |klass|
            begin
              # "nullable: true"
              next if klass == :AnyType
              typed_data = find_and_cast_into_type(klass, data)
              return typed_data if typed_data
              # rescue all errors so we keep iterating even if the current item lookup raises
            rescue
            end
          end

          openapi_one_of.include?(:AnyType) ? data : nil
        end

        private

        SchemaMismatchError = Class.new(StandardError)

        def find_and_cast_into_type(klass, data)
          return if data.nil?

          case klass.to_s
          when "Boolean"
            return data if data.instance_of?(TrueClass) || data.instance_of?(FalseClass)
          when "Float"
            return data if data.instance_of?(Float)
          when "Integer"
            return data if data.instance_of?(Integer)
          when "Time"
            return Time.parse(data)
          when "Date"
            return Date.parse(data)
          when "String"
            return data if data.instance_of?(String)
            # "type: object"
          when "Object"
            return data if data.instance_of?(Hash)
            # "type: array"
          when /\AArray<(?<sub_type>.+)>\z/
            if data.instance_of?(Array)
              sub_type = Regexp.last_match[:sub_type]
              return data.map { |item| find_and_cast_into_type(sub_type, item) }
            end
            # "type: object" with "additionalProperties: { ... }"
          when /\AHash<String, (?<sub_type>.+)>\z/
            if data.instance_of?(Hash) && data.keys.all? { |k| k.instance_of?(Symbol) || k.instance_of?(String) }
              sub_type = Regexp.last_match[:sub_type]
              return data.each_with_object({}) { |(k, v), hsh| hsh[k] = find_and_cast_into_type(sub_type, v) }
            end
            # model
          else
            const = Algolia::Search.const_get(klass)
            if const
              if const.respond_to?(:openapi_one_of)
                # nested oneOf model
                model = const.build(data)
              elsif const.respond_to?(:discriminator_attributes)
                if const.discriminator_attributes.all? { |attr| data.key?(attr) }
                  model = const.build_from_hash(data)
                end
              else
                # maybe it's an enum, or doens't have discriminators
                model = const.build_from_hash(data)
              end

              return model if model
            end
          end

          # if no match by now, raise
          raise
        rescue
          raise SchemaMismatchError, "#{data} doesn't match the #{klass} type"
        end
      end
    end

  end
end
