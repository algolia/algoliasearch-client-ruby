# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

require 'date'
require 'time'

module Algolia
  module Search
    class BaseIndexSettings
      # Attributes used for [faceting](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/).  Facets are attributes that let you categorize search results. They can be used for filtering search results. By default, no attribute is used for faceting. Attribute names are case-sensitive.  **Modifiers**  - `filterOnly(\"ATTRIBUTE\")`.   Allows using this attribute as a filter, but doesn't evalue the facet values.  - `searchable(\"ATTRIBUTE\")`.   Allows searching for facet values.  - `afterDistinct(\"ATTRIBUTE\")`.   Evaluates the facet count _after_ deduplication with `distinct`.   This ensures accurate facet counts.   You can apply this modifier to searchable facets: `afterDistinct(searchable(ATTRIBUTE))`.
      attr_accessor :attributes_for_faceting

      # Creates [replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/replicas/).  Replicas are copies of a primary index with the same records but different settings, synonyms, or rules. If you want to offer a different ranking or sorting of your search results, you'll use replica indices. All index operations on a primary index are automatically forwarded to its replicas. To add a replica index, you must provide the complete set of replicas to this parameter. If you omit a replica from this list, the replica turns into a regular, standalone index that will no longer by synced with the primary index.  **Modifier**  - `virtual(\"REPLICA\")`.   Create a virtual replica,   Virtual replicas don't increase the number of records and are optimized for [Relevant sorting](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/in-depth/relevant-sort/).
      attr_accessor :replicas

      # Only present if the index is a [virtual replica](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/sort-an-index-alphabetically/#virtual-replicas).
      attr_accessor :virtual

      # Maximum number of search results that can be obtained through pagination.  Higher pagination limits might slow down your search. For pagination limits above 1,000, the sorting of results beyond the 1,000th hit can't be guaranteed.
      attr_accessor :pagination_limited_to

      # Attributes that can't be retrieved at query time.  This can be useful if you want to use an attribute for ranking or to [restrict access](https://www.algolia.com/doc/guides/security/api-keys/how-to/user-restricted-access-to-data/), but don't want to include it in the search results. Attribute names are case-sensitive.
      attr_accessor :unretrievable_attributes

      # Words for which you want to turn off [typo tolerance](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/typo-tolerance/). This also turns off [word splitting and concatenation](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/splitting-and-concatenation/) for the specified words.
      attr_accessor :disable_typo_tolerance_on_words

      # Attributes, for which you want to support [Japanese transliteration](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/language-specific-configurations/#japanese-transliteration-and-type-ahead).  Transliteration supports searching in any of the Japanese writing systems. To support transliteration, you must set the indexing language to Japanese. Attribute names are case-sensitive.
      attr_accessor :attributes_to_transliterate

      # Attributes for which to split [camel case](https://wikipedia.org/wiki/Camel_case) words. Attribute names are case-sensitive.
      attr_accessor :camel_case_attributes

      # Searchable attributes to which Algolia should apply [word segmentation](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) (decompounding). Attribute names are case-sensitive.  Compound words are formed by combining two or more individual words, and are particularly prevalent in Germanic languages—for example, \"firefighter\". With decompounding, the individual components are indexed separately.  You can specify different lists for different languages. Decompounding is supported for these languages: Dutch (`nl`), German (`de`), Finnish (`fi`), Danish (`da`), Swedish (`sv`), and Norwegian (`no`).
      attr_accessor :decompounded_attributes

      # Languages for language-specific processing steps, such as word detection and dictionary settings.  **You should always specify an indexing language.** If you don't specify an indexing language, the search engine uses all [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/), or the languages you specified with the `ignorePlurals` or `removeStopWords` parameters. This can lead to unexpected search results. For more information, see [Language-specific configuration](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/language-specific-configurations/).
      attr_accessor :index_languages

      # Searchable attributes for which you want to turn off [prefix matching](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/override-search-engine-defaults/#adjusting-prefix-search). Attribute names are case-sensitive.
      attr_accessor :disable_prefix_on_attributes

      # Whether arrays with exclusively non-negative integers should be compressed for better performance. If true, the compressed arrays may be reordered.
      attr_accessor :allow_compression_of_integer_array

      # Numeric attributes that can be used as [numerical filters](https://www.algolia.com/doc/guides/managing-results/rules/detecting-intent/how-to/applying-a-custom-filter-for-a-specific-query/#numerical-filters). Attribute names are case-sensitive.  By default, all numeric attributes are available as numerical filters. For faster indexing, reduce the number of numeric attributes.  If you want to turn off filtering for all numeric attributes, specifiy an attribute that doesn't exist in your index, such as `NO_NUMERIC_FILTERING`.  **Modifier**  - `equalOnly(\"ATTRIBUTE\")`.   Support only filtering based on equality comparisons `=` and `!=`.
      attr_accessor :numeric_attributes_for_filtering

      # Controls which separators are indexed.  Separators are all non-letter characters except spaces and currency characters, such as $€£¥. By default, separator characters aren't indexed. With `separatorsToIndex`, Algolia treats separator characters as separate words. For example, a search for `C#` would report two matches.
      attr_accessor :separators_to_index

      # Attributes used for searching. Attribute names are case-sensitive.  By default, all attributes are searchable and the [Attribute](https://www.algolia.com/doc/guides/managing-results/relevance-overview/in-depth/ranking-criteria/#attribute) ranking criterion is turned off. With a non-empty list, Algolia only returns results with matches in the selected attributes. In addition, the Attribute ranking criterion is turned on: matches in attributes that are higher in the list of `searchableAttributes` rank first. To make matches in two attributes rank equally, include them in a comma-separated string, such as `\"title,alternate_title\"`. Attributes with the same priority are always unordered.  For more information, see [Searchable attributes](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/setting-searchable-attributes/).  **Modifier**  - `unordered(\"ATTRIBUTE\")`.   Ignore the position of a match within the attribute.  Without modifier, matches at the beginning of an attribute rank higer than matches at the end.
      attr_accessor :searchable_attributes

      # An object with custom data.  You can store up to 32kB as custom data.
      attr_accessor :user_data

      # Characters and their normalized replacements. This overrides Algolia's default [normalization](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/normalization/).
      attr_accessor :custom_normalization

      # Attribute that should be used to establish groups of results. Attribute names are case-sensitive.  All records with the same value for this attribute are considered a group. You can combine `attributeForDistinct` with the `distinct` search parameter to control how many items per group are included in the search results.  If you want to use the same attribute also for faceting, use the `afterDistinct` modifier of the `attributesForFaceting` setting. This applies faceting _after_ deduplication, which will result in accurate facet counts.
      attr_accessor :attribute_for_distinct

      # Attribute mapping from ruby-style variable name to JSON key.
      def self.attribute_map
        {
          :attributes_for_faceting => :attributesForFaceting,
          :replicas => :replicas,
          :virtual => :virtual,
          :pagination_limited_to => :paginationLimitedTo,
          :unretrievable_attributes => :unretrievableAttributes,
          :disable_typo_tolerance_on_words => :disableTypoToleranceOnWords,
          :attributes_to_transliterate => :attributesToTransliterate,
          :camel_case_attributes => :camelCaseAttributes,
          :decompounded_attributes => :decompoundedAttributes,
          :index_languages => :indexLanguages,
          :disable_prefix_on_attributes => :disablePrefixOnAttributes,
          :allow_compression_of_integer_array => :allowCompressionOfIntegerArray,
          :numeric_attributes_for_filtering => :numericAttributesForFiltering,
          :separators_to_index => :separatorsToIndex,
          :searchable_attributes => :searchableAttributes,
          :user_data => :userData,
          :custom_normalization => :customNormalization,
          :attribute_for_distinct => :attributeForDistinct
        }
      end

      # Returns all the JSON keys this model knows about
      def self.acceptable_attributes
        attribute_map.values
      end

      # Attribute type mapping.
      def self.types_mapping
        {
          :attributes_for_faceting => :'Array<String>',
          :replicas => :'Array<String>',
          :virtual => :Boolean,
          :pagination_limited_to => :Integer,
          :unretrievable_attributes => :'Array<String>',
          :disable_typo_tolerance_on_words => :'Array<String>',
          :attributes_to_transliterate => :'Array<String>',
          :camel_case_attributes => :'Array<String>',
          :decompounded_attributes => :Object,
          :index_languages => :'Array<SupportedLanguage>',
          :disable_prefix_on_attributes => :'Array<String>',
          :allow_compression_of_integer_array => :Boolean,
          :numeric_attributes_for_filtering => :'Array<String>',
          :separators_to_index => :String,
          :searchable_attributes => :'Array<String>',
          :user_data => :Object,
          :custom_normalization => :'Hash<String, Hash<String, String>>',
          :attribute_for_distinct => :String
        }
      end

      # List of attributes with nullable: true
      def self.openapi_nullable
        Set.new([])
      end

      # Initializes the object
      # @param [Hash] attributes Model attributes in the form of hash
      def initialize(attributes = {})
        unless attributes.is_a?(Hash)
          raise ArgumentError, "The input argument (attributes) must be a hash in `Algolia::BaseIndexSettings` initialize method"
        end

        # check to see if the attribute exists and convert string to symbol for hash key
        attributes = attributes.each_with_object({}) do |(k, v), h|
          unless self.class.attribute_map.key?(k.to_sym)
            raise ArgumentError,
                  "`#{k}` is not a valid attribute in `Algolia::BaseIndexSettings`. Please check the name to make sure it's valid. List of attributes: " + self.class.attribute_map.keys.inspect
          end

          h[k.to_sym] = v
        end

        if attributes.key?(:attributes_for_faceting)
          if (value = attributes[:attributes_for_faceting]).is_a?(Array)
            self.attributes_for_faceting = value
          end
        end

        if attributes.key?(:replicas)
          if (value = attributes[:replicas]).is_a?(Array)
            self.replicas = value
          end
        end

        if attributes.key?(:virtual)
          self.virtual = attributes[:virtual]
        end

        if attributes.key?(:pagination_limited_to)
          self.pagination_limited_to = attributes[:pagination_limited_to]
        end

        if attributes.key?(:unretrievable_attributes)
          if (value = attributes[:unretrievable_attributes]).is_a?(Array)
            self.unretrievable_attributes = value
          end
        end

        if attributes.key?(:disable_typo_tolerance_on_words)
          if (value = attributes[:disable_typo_tolerance_on_words]).is_a?(Array)
            self.disable_typo_tolerance_on_words = value
          end
        end

        if attributes.key?(:attributes_to_transliterate)
          if (value = attributes[:attributes_to_transliterate]).is_a?(Array)
            self.attributes_to_transliterate = value
          end
        end

        if attributes.key?(:camel_case_attributes)
          if (value = attributes[:camel_case_attributes]).is_a?(Array)
            self.camel_case_attributes = value
          end
        end

        if attributes.key?(:decompounded_attributes)
          self.decompounded_attributes = attributes[:decompounded_attributes]
        end

        if attributes.key?(:index_languages)
          if (value = attributes[:index_languages]).is_a?(Array)
            self.index_languages = value
          end
        end

        if attributes.key?(:disable_prefix_on_attributes)
          if (value = attributes[:disable_prefix_on_attributes]).is_a?(Array)
            self.disable_prefix_on_attributes = value
          end
        end

        if attributes.key?(:allow_compression_of_integer_array)
          self.allow_compression_of_integer_array = attributes[:allow_compression_of_integer_array]
        end

        if attributes.key?(:numeric_attributes_for_filtering)
          if (value = attributes[:numeric_attributes_for_filtering]).is_a?(Array)
            self.numeric_attributes_for_filtering = value
          end
        end

        if attributes.key?(:separators_to_index)
          self.separators_to_index = attributes[:separators_to_index]
        end

        if attributes.key?(:searchable_attributes)
          if (value = attributes[:searchable_attributes]).is_a?(Array)
            self.searchable_attributes = value
          end
        end

        if attributes.key?(:user_data)
          self.user_data = attributes[:user_data]
        end

        if attributes.key?(:custom_normalization)
          if (value = attributes[:custom_normalization]).is_a?(Hash)
            self.custom_normalization = value
          end
        end

        if attributes.key?(:attribute_for_distinct)
          self.attribute_for_distinct = attributes[:attribute_for_distinct]
        end
      end

      # Custom attribute writer method with validation
      # @param [Object] pagination_limited_to Value to be assigned
      def pagination_limited_to=(pagination_limited_to)
        if pagination_limited_to.nil?
          raise ArgumentError, 'pagination_limited_to cannot be nil'
        end

        if pagination_limited_to > 20_000
          raise ArgumentError, 'invalid value for "pagination_limited_to", must be smaller than or equal to 20000.'
        end

        @pagination_limited_to = pagination_limited_to
      end

      # Checks equality by comparing each attribute.
      # @param [Object] Object to be compared
      def ==(other)
        return true if equal?(other)

        self.class == other.class &&
          attributes_for_faceting == other.attributes_for_faceting &&
          replicas == other.replicas &&
          virtual == other.virtual &&
          pagination_limited_to == other.pagination_limited_to &&
          unretrievable_attributes == other.unretrievable_attributes &&
          disable_typo_tolerance_on_words == other.disable_typo_tolerance_on_words &&
          attributes_to_transliterate == other.attributes_to_transliterate &&
          camel_case_attributes == other.camel_case_attributes &&
          decompounded_attributes == other.decompounded_attributes &&
          index_languages == other.index_languages &&
          disable_prefix_on_attributes == other.disable_prefix_on_attributes &&
          allow_compression_of_integer_array == other.allow_compression_of_integer_array &&
          numeric_attributes_for_filtering == other.numeric_attributes_for_filtering &&
          separators_to_index == other.separators_to_index &&
          searchable_attributes == other.searchable_attributes &&
          user_data == other.user_data &&
          custom_normalization == other.custom_normalization &&
          attribute_for_distinct == other.attribute_for_distinct
      end

      # @see the `==` method
      # @param [Object] Object to be compared
      def eql?(other)
        self == other
      end

      # Calculates hash code according to all attributes.
      # @return [Integer] Hash code
      def hash
        [attributes_for_faceting, replicas, virtual, pagination_limited_to, unretrievable_attributes, disable_typo_tolerance_on_words, attributes_to_transliterate,
         camel_case_attributes, decompounded_attributes, index_languages, disable_prefix_on_attributes, allow_compression_of_integer_array, numeric_attributes_for_filtering, separators_to_index, searchable_attributes, user_data, custom_normalization, attribute_for_distinct].hash
      end

      # Builds the object from hash
      # @param [Hash] attributes Model attributes in the form of hash
      # @return [Object] Returns the model itself
      def self.build_from_hash(attributes)
        return nil unless attributes.is_a?(Hash)

        attributes = attributes.transform_keys(&:to_sym)
        transformed_hash = {}
        types_mapping.each_pair do |key, type|
          if attributes.key?(attribute_map[key]) && attributes[attribute_map[key]].nil?
            transformed_hash[key.to_sym] = nil
          elsif type =~ /\AArray<(.*)>/i
            # check to ensure the input is an array given that the attribute
            # is documented as an array but the input is not
            if attributes[attribute_map[key]].is_a?(Array)
              transformed_hash[key.to_sym] = attributes[attribute_map[key]].map { |v| _deserialize(::Regexp.last_match(1), v) }
            end
          elsif !attributes[attribute_map[key]].nil?
            transformed_hash[key.to_sym] = _deserialize(type, attributes[attribute_map[key]])
          end
        end
        new(transformed_hash)
      end

      # Deserializes the data based on type
      # @param string type Data type
      # @param string value Value to be deserialized
      # @return [Object] Deserialized data
      def self._deserialize(type, value)
        case type.to_sym
        when :Time
          Time.parse(value)
        when :Date
          Date.parse(value)
        when :String
          value.to_s
        when :Integer
          value.to_i
        when :Float
          value.to_f
        when :Boolean
          if value.to_s =~ /\A(true|t|yes|y|1)\z/i
            true
          else
            false
          end
        when :Object
          # generic object (usually a Hash), return directly
          value
        when /\AArray<(?<inner_type>.+)>\z/
          inner_type = Regexp.last_match[:inner_type]
          value.map { |v| _deserialize(inner_type, v) }
        when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
          k_type = Regexp.last_match[:k_type]
          v_type = Regexp.last_match[:v_type]
          {}.tap do |hash|
            value.each do |k, v|
              hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
            end
          end
        else # model
          # models (e.g. Pet) or oneOf
          klass = Algolia::Search.const_get(type)
          klass.respond_to?(:openapi_any_of) || klass.respond_to?(:openapi_one_of) ? klass.build(value) : klass.build_from_hash(value)
        end
      end

      # Returns the string representation of the object
      # @return [String] String presentation of the object
      def to_s
        to_hash.to_s
      end

      # to_body is an alias to to_hash (backward compatibility)
      # @return [Hash] Returns the object in the form of hash
      def to_body
        to_hash
      end

      def to_json(*_args)
        to_hash.to_json
      end

      # Returns the object in the form of hash
      # @return [Hash] Returns the object in the form of hash
      def to_hash
        hash = {}
        self.class.attribute_map.each_pair do |attr, param|
          value = send(attr)
          if value.nil?
            is_nullable = self.class.openapi_nullable.include?(attr)
            next if !is_nullable || (is_nullable && !instance_variable_defined?(:"@#{attr}"))
          end

          hash[param] = _to_hash(value)
        end
        hash
      end

      # Outputs non-array value in the form of hash
      # For object, use to_hash. Otherwise, just return the value
      # @param [Object] value Any valid value
      # @return [Hash] Returns the value in the form of hash
      def _to_hash(value)
        if value.is_a?(Array)
          value.compact.map { |v| _to_hash(v) }
        elsif value.is_a?(Hash)
          {}.tap do |hash|
            value.each { |k, v| hash[k] = _to_hash(v) }
          end
        elsif value.respond_to? :to_hash
          value.to_hash
        else
          value
        end
      end
    end
  end
end
