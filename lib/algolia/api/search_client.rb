# frozen_string_literal: true

# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

require "openssl"
require "base64"

module Algolia
  class SearchClient
    attr_accessor :api_client

    def initialize(config = nil)
      raise "`config` is missing." if config.nil?
      raise "`app_id` is missing." if config.app_id.nil? || config.app_id == ""
      raise "`api_key` is missing." if config.api_key.nil? || config.api_key == ""

      @api_client = Algolia::ApiClient.new(config)
    end

    def self.create(app_id, api_key, opts = {})
      hosts = []
      hosts << Transport::StatefulHost.new("#{app_id}-dsn.algolia.net", accept: CallType::READ)
      hosts << Transport::StatefulHost.new("#{app_id}.algolia.net", accept: CallType::WRITE)

      hosts += 1
        .upto(3)
        .map do |i|
          Transport::StatefulHost.new("#{app_id}-#{i}.algolianet.com", accept: CallType::READ | CallType::WRITE)
        end
        .shuffle

      config = Algolia::Configuration.new(app_id, api_key, hosts, "Search", opts)
      create_with_config(config)
    end

    def self.create_with_config(config)
      if config.connect_timeout.nil?
        config.connect_timeout = 2000
      end

      if config.read_timeout.nil?
        config.read_timeout = 5000
      end

      if config.write_timeout.nil?
        config.write_timeout = 30000
      end

      new(config)
    end

    # Helper method to switch the API key used to authenticate the requests.
    #
    # @param api_key [String] the new API key to use.
    # @return [void]
    def set_client_api_key(api_key)
      @api_client.set_client_api_key(api_key)

      self
    end

    def add_user_agent_segment(segment, version = nil)
      @api_client.config.add_user_agent_segment(segment, version)

      self
    end

    # Creates a new API key with specific permissions and restrictions.
    #
    # Required API Key ACLs:
    #   - admin
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def add_api_key_with_http_info(api_key, request_options = {})
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Parameter `api_key` is required when calling `add_api_key`."
      end

      path = "/1/keys"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(api_key)

      new_options = request_options.merge(
        :operation => :"SearchClient.add_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new API key with specific permissions and restrictions.
    #
    # Required API Key ACLs:
    #   - admin
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AddApiKeyResponse]
    def add_api_key(api_key, request_options = {})
      response = add_api_key_with_http_info(api_key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::AddApiKeyResponse")
    end

    # If a record with the specified object ID exists, the existing record is replaced. Otherwise, a new record is added to the index.  If you want to use auto-generated object IDs, use the [`saveObject` operation](#tag/Records/operation/saveObject). To update _some_ attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead. To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param body [Object] The record. A schemaless object with attributes that are useful in the context of search and discovery. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def add_or_update_object_with_http_info(index_name, algolia_object_id, body, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `add_or_update_object`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `add_or_update_object`."
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Parameter `body` is required when calling `add_or_update_object`."
      end

      path = "/1/indexes/{indexName}/{objectID}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s)).sub(
        "{" + "objectID" + "}",
        Transport.encode_uri(algolia_object_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"SearchClient.add_or_update_object",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # If a record with the specified object ID exists, the existing record is replaced. Otherwise, a new record is added to the index.  If you want to use auto-generated object IDs, use the [`saveObject` operation](#tag/Records/operation/saveObject). To update _some_ attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead. To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param body [Object] The record. A schemaless object with attributes that are useful in the context of search and discovery. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtWithObjectIdResponse]
    def add_or_update_object(index_name, algolia_object_id, body, request_options = {})
      response = add_or_update_object_with_http_info(index_name, algolia_object_id, body, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::UpdatedAtWithObjectIdResponse"
      )
    end

    # Adds a source to the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [Source] Source to add. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def append_source_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `append_source`."
      end

      path = "/1/security/sources/append"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source)

      new_options = request_options.merge(
        :operation => :"SearchClient.append_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds a source to the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [Source] Source to add. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def append_source(source, request_options = {})
      response = append_source_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::CreatedAtResponse")
    end

    # Assigns or moves a user ID to a cluster.  The time it takes to move a user is proportional to the amount of data linked to the user ID.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param x_algolia_user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param assign_user_id_params [AssignUserIdParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, request_options = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Parameter `x_algolia_user_id` is required when calling `assign_user_id`."
      end
      # verify the required parameter 'assign_user_id_params' is set
      if @api_client.config.client_side_validation && assign_user_id_params.nil?
        raise ArgumentError, "Parameter `assign_user_id_params` is required when calling `assign_user_id`."
      end

      path = "/1/clusters/mapping"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params[:"X-Algolia-User-ID"] = x_algolia_user_id
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(assign_user_id_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.assign_user_id",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Assigns or moves a user ID to a cluster.  The time it takes to move a user is proportional to the amount of data linked to the user ID.
    #
    # Required API Key ACLs:
    #   - admin
    # @param x_algolia_user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param assign_user_id_params [AssignUserIdParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def assign_user_id(x_algolia_user_id, assign_user_id_params, request_options = {})
      response = assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::CreatedAtResponse")
    end

    # Adds, updates, or deletes records in one index with a single API request.  Batching index updates reduces latency and increases data integrity.  - Actions are applied in the order they're specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param batch_write_params [BatchWriteParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_with_http_info(index_name, batch_write_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `batch`."
      end
      # verify the required parameter 'batch_write_params' is set
      if @api_client.config.client_side_validation && batch_write_params.nil?
        raise ArgumentError, "Parameter `batch_write_params` is required when calling `batch`."
      end

      path = "/1/indexes/{indexName}/batch".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_write_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.batch",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds, updates, or deletes records in one index with a single API request.  Batching index updates reduces latency and increases data integrity.  - Actions are applied in the order they're specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param batch_write_params [BatchWriteParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [BatchResponse]
    def batch(index_name, batch_write_params, request_options = {})
      response = batch_with_http_info(index_name, batch_write_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::BatchResponse")
    end

    # Assigns multiple user IDs to a cluster.  **You can't move users with this operation**.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param x_algolia_user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, request_options = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Parameter `x_algolia_user_id` is required when calling `batch_assign_user_ids`."
      end
      # verify the required parameter 'batch_assign_user_ids_params' is set
      if @api_client.config.client_side_validation && batch_assign_user_ids_params.nil?
        raise(
          ArgumentError,
          "Parameter `batch_assign_user_ids_params` is required when calling `batch_assign_user_ids`."
        )
      end

      path = "/1/clusters/mapping/batch"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params[:"X-Algolia-User-ID"] = x_algolia_user_id
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_assign_user_ids_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.batch_assign_user_ids",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Assigns multiple user IDs to a cluster.  **You can't move users with this operation**.
    #
    # Required API Key ACLs:
    #   - admin
    # @param x_algolia_user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def batch_assign_user_ids(x_algolia_user_id, batch_assign_user_ids_params, request_options = {})
      response = batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::CreatedAtResponse")
    end

    # Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param dictionary_name [DictionaryType] Dictionary type in which to search. (required)
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_dictionary_entries_with_http_info(dictionary_name, batch_dictionary_entries_params, request_options = {})
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Parameter `dictionary_name` is required when calling `batch_dictionary_entries`."
      end
      # verify the required parameter 'batch_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && batch_dictionary_entries_params.nil?
        raise(
          ArgumentError,
          "Parameter `batch_dictionary_entries_params` is required when calling `batch_dictionary_entries`."
        )
      end

      path = "/1/dictionaries/{dictionaryName}/batch".sub(
        "{" + "dictionaryName" + "}",
        Transport.encode_uri(dictionary_name.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_dictionary_entries_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.batch_dictionary_entries",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds or deletes multiple entries from your plurals, segmentation, or stop word dictionaries.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param dictionary_name [DictionaryType] Dictionary type in which to search. (required)
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def batch_dictionary_entries(dictionary_name, batch_dictionary_entries_params, request_options = {})
      response = batch_dictionary_entries_with_http_info(
        dictionary_name,
        batch_dictionary_entries_params,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Retrieves records from an index, up to 1,000 per request.  While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details), browsing _just_ returns matching records. This can be useful if you want to export your indices.  - The Analytics API doesn't collect data when using `browse`. - Records are ranked by attributes and custom ranking. - There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.  Browse requests automatically apply these settings:  - `advancedSyntax`: `false` - `attributesToHighlight`: `[]` - `attributesToSnippet`: `[]` - `distinct`: `false` - `enablePersonalization`: `false` - `enableRules`: `false` - `facets`: `[]` - `getRankingInfo`: `false` - `ignorePlurals`: `false` - `optionalFilters`: `[]` - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)  If you send these parameters with your browse requests, they'll be ignored.
    #
    # Required API Key ACLs:
    #   - browse
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param browse_params [BrowseParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def browse_with_http_info(index_name, browse_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `browse`."
      end

      path = "/1/indexes/{indexName}/browse".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(browse_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.browse",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Retrieves records from an index, up to 1,000 per request.  While searching retrieves _hits_ (records augmented with attributes for highlighting and ranking details), browsing _just_ returns matching records. This can be useful if you want to export your indices.  - The Analytics API doesn't collect data when using `browse`. - Records are ranked by attributes and custom ranking. - There's no ranking for: typo-tolerance, number of matched words, proximity, geo distance.  Browse requests automatically apply these settings:  - `advancedSyntax`: `false` - `attributesToHighlight`: `[]` - `attributesToSnippet`: `[]` - `distinct`: `false` - `enablePersonalization`: `false` - `enableRules`: `false` - `facets`: `[]` - `getRankingInfo`: `false` - `ignorePlurals`: `false` - `optionalFilters`: `[]` - `typoTolerance`: `true` or `false` (`min` and `strict` evaluate to `true`)  If you send these parameters with your browse requests, they'll be ignored.
    #
    # Required API Key ACLs:
    #   - browse
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param browse_params [BrowseParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [BrowseResponse]
    def browse(index_name, browse_params = nil, request_options = {})
      response = browse_with_http_info(index_name, browse_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::BrowseResponse")
    end

    # Deletes only the records from an index while keeping settings, synonyms, and rules. This operation is resource-intensive and subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_objects_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_objects`."
      end

      path = "/1/indexes/{indexName}/clear".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.clear_objects",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Deletes only the records from an index while keeping settings, synonyms, and rules. This operation is resource-intensive and subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_objects(index_name, request_options = {})
      response = clear_objects_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Deletes all rules from the index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_rules_with_http_info(index_name, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_rules`."
      end

      path = "/1/indexes/{indexName}/rules/clear".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.clear_rules",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Deletes all rules from the index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_rules(index_name, forward_to_replicas = nil, request_options = {})
      response = clear_rules_with_http_info(index_name, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Deletes all synonyms from the index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_synonyms_with_http_info(index_name, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_synonyms`."
      end

      path = "/1/indexes/{indexName}/synonyms/clear".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.clear_synonyms",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Deletes all synonyms from the index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_synonyms(index_name, forward_to_replicas = nil, request_options = {})
      response = clear_synonyms_with_http_info(index_name, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_delete_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_delete`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.custom_delete",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_delete(path, parameters = nil, request_options = {})
      response = custom_delete_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_get_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_get`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.custom_get",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_get(path, parameters = nil, request_options = {})
      response = custom_get_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_post_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_post`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"SearchClient.custom_post",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_post(path, parameters = nil, body = nil, request_options = {})
      response = custom_post_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_put_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_put`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"SearchClient.custom_put",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_put(path, parameters = nil, body = nil, request_options = {})
      response = custom_put_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # Deletes the API key.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `delete_api_key`."
      end

      path = "/1/keys/{key}".sub("{" + "key" + "}", Transport.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes the API key.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteApiKeyResponse]
    def delete_api_key(key, request_options = {})
      response = delete_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::DeleteApiKeyResponse")
    end

    # This operation doesn't accept empty filters.  This operation is resource-intensive. You should only use it if you can't get the object IDs of the records you want to delete. It's more efficient to get a list of object IDs with the [`browse` operation](#tag/Search/operation/browse), and then delete the records using the [`batch` operation](#tag/Records/operation/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param delete_by_params [DeleteByParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_by_with_http_info(index_name, delete_by_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_by`."
      end
      # verify the required parameter 'delete_by_params' is set
      if @api_client.config.client_side_validation && delete_by_params.nil?
        raise ArgumentError, "Parameter `delete_by_params` is required when calling `delete_by`."
      end

      path = "/1/indexes/{indexName}/deleteByQuery".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(delete_by_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_by",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # This operation doesn't accept empty filters.  This operation is resource-intensive. You should only use it if you can't get the object IDs of the records you want to delete. It's more efficient to get a list of object IDs with the [`browse` operation](#tag/Search/operation/browse), and then delete the records using the [`batch` operation](#tag/Records/operation/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param delete_by_params [DeleteByParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def delete_by(index_name, delete_by_params, request_options = {})
      response = delete_by_with_http_info(index_name, delete_by_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Deletes an index and all its settings.  - Deleting an index doesn't delete its analytics data. - If you try to delete a non-existing index, the operation is ignored without warning. - If the index you want to delete has replica indices, the replicas become independent indices. - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.   For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas/).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_index_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_index`."
      end

      path = "/1/indexes/{indexName}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_index",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes an index and all its settings.  - Deleting an index doesn't delete its analytics data. - If you try to delete a non-existing index, the operation is ignored without warning. - If the index you want to delete has replica indices, the replicas become independent indices. - If the index you want to delete is a replica index, you must first unlink it from its primary index before you can delete it.   For more information, see [Delete replica indices](https://www.algolia.com/doc/guides/managing-results/refine-results/sorting/how-to/deleting-replicas/).
    #
    # Required API Key ACLs:
    #   - deleteIndex
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_index(index_name, request_options = {})
      response = delete_index_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::DeletedAtResponse")
    end

    # Deletes a record by its object ID.  To delete more than one record, use the [`batch` operation](#tag/Records/operation/batch). To delete records matching a query, use the [`deleteBy` operation](#tag/Records/operation/deleteBy).
    #
    # Required API Key ACLs:
    #   - deleteObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_object_with_http_info(index_name, algolia_object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_object`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `delete_object`."
      end

      path = "/1/indexes/{indexName}/{objectID}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s)).sub(
        "{" + "objectID" + "}",
        Transport.encode_uri(algolia_object_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_object",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a record by its object ID.  To delete more than one record, use the [`batch` operation](#tag/Records/operation/batch). To delete records matching a query, use the [`deleteBy` operation](#tag/Records/operation/deleteBy).
    #
    # Required API Key ACLs:
    #   - deleteObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_object(index_name, algolia_object_id, request_options = {})
      response = delete_object_with_http_info(index_name, algolia_object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::DeletedAtResponse")
    end

    # Deletes a rule by its ID. To find the object ID for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_rule_with_http_info(index_name, algolia_object_id, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_rule`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `delete_rule`."
      end

      path = "/1/indexes/{indexName}/rules/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_rule",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a rule by its ID. To find the object ID for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def delete_rule(index_name, algolia_object_id, forward_to_replicas = nil, request_options = {})
      response = delete_rule_with_http_info(index_name, algolia_object_id, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Deletes a source from the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [String] IP address range of the source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_source_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `delete_source`."
      end

      path = "/1/security/sources/{source}".sub("{" + "source" + "}", Transport.encode_uri(source.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a source from the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [String] IP address range of the source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteSourceResponse]
    def delete_source(source, request_options = {})
      response = delete_source_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::DeleteSourceResponse")
    end

    # Deletes a synonym by its ID. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_synonym_with_http_info(index_name, algolia_object_id, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_synonym`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `delete_synonym`."
      end

      path = "/1/indexes/{indexName}/synonyms/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.delete_synonym",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a synonym by its ID. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_synonym(index_name, algolia_object_id, forward_to_replicas = nil, request_options = {})
      response = delete_synonym_with_http_info(index_name, algolia_object_id, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::DeletedAtResponse")
    end

    # Gets the permissions and restrictions of an API key.  When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key, with the description replaced by `<redacted>`.

    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `get_api_key`."
      end

      path = "/1/keys/{key}".sub("{" + "key" + "}", Transport.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Gets the permissions and restrictions of an API key.  When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key, with the description replaced by `<redacted>`.

    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetApiKeyResponse]
    def get_api_key(key, request_options = {})
      response = get_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetApiKeyResponse")
    end

    # Checks the status of a given application task.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_app_task_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `get_app_task`."
      end

      path = "/1/task/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_app_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Checks the status of a given application task.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetTaskResponse]
    def get_app_task(task_id, request_options = {})
      response = get_app_task_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetTaskResponse")
    end

    # Lists supported languages with their supported dictionary types and number of custom entries.
    #
    # Required API Key ACLs:
    #   - settings
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_dictionary_languages_with_http_info(request_options = {})
      path = "/1/dictionaries/*/languages"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_dictionary_languages",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Lists supported languages with their supported dictionary types and number of custom entries.
    #
    # Required API Key ACLs:
    #   - settings
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Hash<String, Languages>]
    def get_dictionary_languages(request_options = {})
      response = get_dictionary_languages_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Hash<String, Languages>")
    end

    # Retrieves the languages for which standard dictionary entries are turned off.
    #
    # Required API Key ACLs:
    #   - settings
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_dictionary_settings_with_http_info(request_options = {})
      path = "/1/dictionaries/*/settings"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_dictionary_settings",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves the languages for which standard dictionary entries are turned off.
    #
    # Required API Key ACLs:
    #   - settings
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetDictionarySettingsResponse]
    def get_dictionary_settings(request_options = {})
      response = get_dictionary_settings_with_http_info(request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::GetDictionarySettingsResponse"
      )
    end

    # The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).  - Logs are held for the last seven days. - Up to 1,000 API requests per server are logged. - This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.
    #
    # Required API Key ACLs:
    #   - logs
    # @param offset [Integer] First log entry to retrieve. The most recent entries are listed first. (default to 0)
    # @param length [Integer] Maximum number of entries to retrieve. (default to 10)
    # @param index_name [String] Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
    # @param type [LogType] Type of log entries to retrieve. By default, all log entries are retrieved.  (default to 'all')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_logs_with_http_info(offset = nil, length = nil, index_name = nil, type = nil, request_options = {})
      path = "/1/logs"
      query_params = {}
      query_params[:offset] = offset unless offset.nil?
      query_params[:length] = length unless length.nil?
      query_params[:indexName] = index_name unless index_name.nil?
      query_params[:type] = type unless type.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_logs",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl).  - Logs are held for the last seven days. - Up to 1,000 API requests per server are logged. - This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself.
    #
    # Required API Key ACLs:
    #   - logs
    # @param offset [Integer] First log entry to retrieve. The most recent entries are listed first. (default to 0)
    # @param length [Integer] Maximum number of entries to retrieve. (default to 10)
    # @param index_name [String] Index for which to retrieve log entries. By default, log entries are retrieved for all indices.
    # @param type [LogType] Type of log entries to retrieve. By default, all log entries are retrieved.  (default to 'all')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetLogsResponse]
    def get_logs(offset = nil, length = nil, index_name = nil, type = nil, request_options = {})
      response = get_logs_with_http_info(offset, length, index_name, type, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetLogsResponse")
    end

    # Retrieves one record by its object ID.  To retrieve more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param attributes_to_retrieve [Array<String>] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_object_with_http_info(index_name, algolia_object_id, attributes_to_retrieve = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_object`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `get_object`."
      end

      path = "/1/indexes/{indexName}/{objectID}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s)).sub(
        "{" + "objectID" + "}",
        Transport.encode_uri(algolia_object_id.to_s)
      )
      query_params = {}
      unless attributes_to_retrieve.nil?
        query_params[:attributesToRetrieve] = @api_client.build_collection_param(attributes_to_retrieve, :multi)
      end

      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_object",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves one record by its object ID.  To retrieve more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param attributes_to_retrieve [Array<String>] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned.  `objectID` is always retrieved.  Attributes included in `unretrievableAttributes` won't be retrieved unless the request is authenticated with the admin API key.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def get_object(index_name, algolia_object_id, attributes_to_retrieve = nil, request_options = {})
      response = get_object_with_http_info(index_name, algolia_object_id, attributes_to_retrieve, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # Retrieves one or more records, potentially from different indices.  Records are returned in the same order as the requests.
    #
    # Required API Key ACLs:
    #   - search
    # @param get_objects_params [GetObjectsParams] Request object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_objects_with_http_info(get_objects_params, request_options = {})
      # verify the required parameter 'get_objects_params' is set
      if @api_client.config.client_side_validation && get_objects_params.nil?
        raise ArgumentError, "Parameter `get_objects_params` is required when calling `get_objects`."
      end

      path = "/1/indexes/*/objects"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(get_objects_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.get_objects",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Retrieves one or more records, potentially from different indices.  Records are returned in the same order as the requests.
    #
    # Required API Key ACLs:
    #   - search
    # @param get_objects_params [GetObjectsParams] Request object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetObjectsResponse]
    def get_objects(get_objects_params, request_options = {})
      response = get_objects_with_http_info(get_objects_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetObjectsResponse")
    end

    # Retrieves a rule by its ID. To find the object ID of rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_rule_with_http_info(index_name, algolia_object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_rule`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `get_rule`."
      end

      path = "/1/indexes/{indexName}/rules/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_rule",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a rule by its ID. To find the object ID of rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Rule]
    def get_rule(index_name, algolia_object_id, request_options = {})
      response = get_rule_with_http_info(index_name, algolia_object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::Rule")
    end

    # Retrieves an object with non-null index settings.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_settings_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_settings`."
      end

      path = "/1/indexes/{indexName}/settings".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_settings",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves an object with non-null index settings.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SettingsResponse]
    def get_settings(index_name, request_options = {})
      response = get_settings_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SettingsResponse")
    end

    # Retrieves all allowed IP addresses with access to your application.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_sources_with_http_info(request_options = {})
      path = "/1/security/sources"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves all allowed IP addresses with access to your application.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Source>]
    def get_sources(request_options = {})
      response = get_sources_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Search::Source>")
    end

    # Retrieves a synonym by its ID. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_synonym_with_http_info(index_name, algolia_object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_synonym`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `get_synonym`."
      end

      path = "/1/indexes/{indexName}/synonyms/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_synonym",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a synonym by its ID. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SynonymHit]
    def get_synonym(index_name, algolia_object_id, request_options = {})
      response = get_synonym_with_http_info(index_name, algolia_object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SynonymHit")
    end

    # Checks the status of a given task.  Indexing tasks are asynchronous. When you add, update, or delete records or indices, a task is created on a queue and completed depending on the load on the server.  The indexing tasks' responses include a task ID that you can use to check the status.
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_task_with_http_info(index_name, task_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_task`."
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `get_task`."
      end

      path = "/1/indexes/{indexName}/task/{taskID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Checks the status of a given task.  Indexing tasks are asynchronous. When you add, update, or delete records or indices, a task is created on a queue and completed depending on the load on the server.  The indexing tasks' responses include a task ID that you can use to check the status.
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetTaskResponse]
    def get_task(index_name, task_id, request_options = {})
      response = get_task_with_http_info(index_name, task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetTaskResponse")
    end

    # Get the IDs of the 10 users with the highest number of records per cluster.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_top_user_ids_with_http_info(request_options = {})
      path = "/1/clusters/mapping/top"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_top_user_ids",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get the IDs of the 10 users with the highest number of records per cluster.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetTopUserIdsResponse]
    def get_top_user_ids(request_options = {})
      response = get_top_user_ids_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::GetTopUserIdsResponse")
    end

    # Returns the user ID data stored in the mapping.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_user_id_with_http_info(user_id, request_options = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Parameter `user_id` is required when calling `get_user_id`."
      end

      path = "/1/clusters/mapping/{userID}".sub("{" + "userID" + "}", Transport.encode_uri(user_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.get_user_id",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Returns the user ID data stored in the mapping.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # @param user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UserId]
    def get_user_id(user_id, request_options = {})
      response = get_user_id_with_http_info(user_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UserId")
    end

    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param get_clusters [Boolean] Whether to include the cluster's pending mapping state in the response.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def has_pending_mappings_with_http_info(get_clusters = nil, request_options = {})
      path = "/1/clusters/mapping/pending"
      query_params = {}
      query_params[:getClusters] = get_clusters unless get_clusters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.has_pending_mappings",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    #
    # Required API Key ACLs:
    #   - admin
    # @param get_clusters [Boolean] Whether to include the cluster's pending mapping state in the response.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [HasPendingMappingsResponse]
    def has_pending_mappings(get_clusters = nil, request_options = {})
      response = has_pending_mappings_with_http_info(get_clusters, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::HasPendingMappingsResponse"
      )
    end

    # Lists all API keys associated with your Algolia application, including their permissions and restrictions.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_api_keys_with_http_info(request_options = {})
      path = "/1/keys"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.list_api_keys",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Lists all API keys associated with your Algolia application, including their permissions and restrictions.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListApiKeysResponse]
    def list_api_keys(request_options = {})
      response = list_api_keys_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::ListApiKeysResponse")
    end

    # Lists the available clusters in a multi-cluster setup.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_clusters_with_http_info(request_options = {})
      path = "/1/clusters"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.list_clusters",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Lists the available clusters in a multi-cluster setup.
    #
    # Required API Key ACLs:
    #   - admin
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListClustersResponse]
    def list_clusters(request_options = {})
      response = list_clusters_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::ListClustersResponse")
    end

    # Lists all indices in the current Algolia application.  The request follows any index restrictions of the API key you use to make the request.
    #
    # Required API Key ACLs:
    #   - listIndexes
    # @param page [Integer] Requested page of the API response. If `null`, the API response is not paginated.
    # @param hits_per_page [Integer] Number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_indices_with_http_info(page = nil, hits_per_page = nil, request_options = {})
      path = "/1/indexes"
      query_params = {}
      query_params[:page] = page unless page.nil?
      query_params[:hitsPerPage] = hits_per_page unless hits_per_page.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.list_indices",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Lists all indices in the current Algolia application.  The request follows any index restrictions of the API key you use to make the request.
    #
    # Required API Key ACLs:
    #   - listIndexes
    # @param page [Integer] Requested page of the API response. If `null`, the API response is not paginated.
    # @param hits_per_page [Integer] Number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListIndicesResponse]
    def list_indices(page = nil, hits_per_page = nil, request_options = {})
      response = list_indices_with_http_info(page, hits_per_page, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::ListIndicesResponse")
    end

    # Lists the userIDs assigned to a multi-cluster application.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param page [Integer] Requested page of the API response. If `null`, the API response is not paginated.
    # @param hits_per_page [Integer] Number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_user_ids_with_http_info(page = nil, hits_per_page = nil, request_options = {})
      path = "/1/clusters/mapping"
      query_params = {}
      query_params[:page] = page unless page.nil?
      query_params[:hitsPerPage] = hits_per_page unless hits_per_page.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.list_user_ids",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Lists the userIDs assigned to a multi-cluster application.  Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.
    #
    # Required API Key ACLs:
    #   - admin
    # @param page [Integer] Requested page of the API response. If `null`, the API response is not paginated.
    # @param hits_per_page [Integer] Number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListUserIdsResponse]
    def list_user_ids(page = nil, hits_per_page = nil, request_options = {})
      response = list_user_ids_with_http_info(page, hits_per_page, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::ListUserIdsResponse")
    end

    # Adds, updates, or deletes records in multiple indices with a single API request.  - Actions are applied in the order they are specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

    # @param batch_params [BatchParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def multiple_batch_with_http_info(batch_params, request_options = {})
      # verify the required parameter 'batch_params' is set
      if @api_client.config.client_side_validation && batch_params.nil?
        raise ArgumentError, "Parameter `batch_params` is required when calling `multiple_batch`."
      end

      path = "/1/indexes/*/batch"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.multiple_batch",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds, updates, or deletes records in multiple indices with a single API request.  - Actions are applied in the order they are specified. - Actions are equivalent to the individual API requests of the same name.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).

    # @param batch_params [BatchParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [MultipleBatchResponse]
    def multiple_batch(batch_params, request_options = {})
      response = multiple_batch_with_http_info(batch_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::MultipleBatchResponse")
    end

    # Copies or moves (renames) an index within the same Algolia application.  - Existing destination indices are overwritten, except for their analytics data. - If the destination index doesn't exist yet, it'll be created. - This operation is resource-intensive.  **Copy**  - Copying a source index that doesn't exist creates a new index with 0 records and default settings. - The API keys of the source index are merged with the existing keys in the destination index. - You can't copy the `enableReRanking`, `mode`, and `replicas` settings. - You can't copy to a destination index that already has replicas. - Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits). - Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)  **Move**  - Moving a source index that doesn't exist is ignored without returning an error. - When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.   To access the original analytics in the dashboard, create an index with the original name. - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices. - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param operation_index_params [OperationIndexParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def operation_index_with_http_info(index_name, operation_index_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `operation_index`."
      end
      # verify the required parameter 'operation_index_params' is set
      if @api_client.config.client_side_validation && operation_index_params.nil?
        raise ArgumentError, "Parameter `operation_index_params` is required when calling `operation_index`."
      end

      path = "/1/indexes/{indexName}/operation".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(operation_index_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.operation_index",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Copies or moves (renames) an index within the same Algolia application.  - Existing destination indices are overwritten, except for their analytics data. - If the destination index doesn't exist yet, it'll be created. - This operation is resource-intensive.  **Copy**  - Copying a source index that doesn't exist creates a new index with 0 records and default settings. - The API keys of the source index are merged with the existing keys in the destination index. - You can't copy the `enableReRanking`, `mode`, and `replicas` settings. - You can't copy to a destination index that already has replicas. - Be aware of the [size limits](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits). - Related guide: [Copy indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/copy-indices/)  **Move**  - Moving a source index that doesn't exist is ignored without returning an error. - When moving an index, the analytics data keeps its original name, and a new set of analytics data is started for the new name.   To access the original analytics in the dashboard, create an index with the original name. - If the destination index has replicas, moving will overwrite the existing index and copy the data to the replica indices. - Related guide: [Move indices](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/how-to/move-indices/).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param operation_index_params [OperationIndexParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def operation_index(index_name, operation_index_params, request_options = {})
      response = operation_index_with_http_info(index_name, operation_index_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Adds new attributes to a record, or updates existing ones.  - If a record with the specified object ID doesn't exist,   a new record is added to the index **if** `createIfNotExists` is true. - If the index doesn't exist yet, this method creates a new index. - You can use any first-level attribute but not nested attributes.   If you specify a nested attribute, this operation replaces its first-level ancestor.  To update an attribute without pushing the entire record, you can use these built-in operations. These operations can be helpful if you don't have access to your initial data.  - Increment: increment a numeric attribute - Decrement: decrement a numeric attribute - Add: append a number or string element to an array attribute - Remove: remove all matching number or string elements from an array attribute made of numbers or strings - AddUnique: add a number or string element to an array attribute made of numbers or strings only if it's not already present - IncrementFrom: increment a numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates it if you pass an IncrementFrom value of 0. - IncrementSet: increment a numeric integer attribute only if the provided value is greater than the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an IncrementSet value greater than 0.  You can specify an operation by providing an object with the attribute to update as the key and its value being an object with the following properties:  - _operation: the operation to apply on the attribute - value: the right-hand side argument to the operation, for example, increment or decrement step, value to add or remove.  When updating multiple attributes or using multiple operations targeting the same record, you should use a single partial update for faster processing.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param attributes_to_update [Object] Attributes with their values. (required)
    # @param create_if_not_exists [Boolean] Whether to create a new record if it doesn't exist. (default to true)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def partial_update_object_with_http_info(
      index_name,
      algolia_object_id,
      attributes_to_update,
      create_if_not_exists = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `partial_update_object`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `partial_update_object`."
      end
      # verify the required parameter 'attributes_to_update' is set
      if @api_client.config.client_side_validation && attributes_to_update.nil?
        raise ArgumentError, "Parameter `attributes_to_update` is required when calling `partial_update_object`."
      end

      path = "/1/indexes/{indexName}/{objectID}/partial"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params[:createIfNotExists] = create_if_not_exists unless create_if_not_exists.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(attributes_to_update)

      new_options = request_options.merge(
        :operation => :"SearchClient.partial_update_object",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds new attributes to a record, or updates existing ones.  - If a record with the specified object ID doesn't exist,   a new record is added to the index **if** `createIfNotExists` is true. - If the index doesn't exist yet, this method creates a new index. - You can use any first-level attribute but not nested attributes.   If you specify a nested attribute, this operation replaces its first-level ancestor.  To update an attribute without pushing the entire record, you can use these built-in operations. These operations can be helpful if you don't have access to your initial data.  - Increment: increment a numeric attribute - Decrement: decrement a numeric attribute - Add: append a number or string element to an array attribute - Remove: remove all matching number or string elements from an array attribute made of numbers or strings - AddUnique: add a number or string element to an array attribute made of numbers or strings only if it's not already present - IncrementFrom: increment a numeric integer attribute only if the provided value matches the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementFrom value of 2 for the version attribute, but the current value of the attribute is 1, the engine ignores the update. If the object doesn't exist, the engine only creates it if you pass an IncrementFrom value of 0. - IncrementSet: increment a numeric integer attribute only if the provided value is greater than the current value, and otherwise ignore the whole object update. For example, if you pass an IncrementSet value of 2 for the version attribute, and the current value of the attribute is 1, the engine updates the object. If the object doesn't exist yet, the engine only creates it if you pass an IncrementSet value greater than 0.  You can specify an operation by providing an object with the attribute to update as the key and its value being an object with the following properties:  - _operation: the operation to apply on the attribute - value: the right-hand side argument to the operation, for example, increment or decrement step, value to add or remove.  When updating multiple attributes or using multiple operations targeting the same record, you should use a single partial update for faster processing.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique record identifier. (required)
    # @param attributes_to_update [Object] Attributes with their values. (required)
    # @param create_if_not_exists [Boolean] Whether to create a new record if it doesn't exist. (default to true)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtWithObjectIdResponse]
    def partial_update_object(
      index_name,
      algolia_object_id,
      attributes_to_update,
      create_if_not_exists = nil,
      request_options = {}
    )
      response = partial_update_object_with_http_info(
        index_name,
        algolia_object_id,
        attributes_to_update,
        create_if_not_exists,
        request_options
      )
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::UpdatedAtWithObjectIdResponse"
      )
    end

    # Deletes a user ID and its associated data from the clusters.
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def remove_user_id_with_http_info(user_id, request_options = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Parameter `user_id` is required when calling `remove_user_id`."
      end

      path = "/1/clusters/mapping/{userID}".sub("{" + "userID" + "}", Transport.encode_uri(user_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.remove_user_id",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a user ID and its associated data from the clusters.
    #
    # Required API Key ACLs:
    #   - admin
    # @param user_id [String] Unique identifier of the user who makes the search request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RemoveUserIdResponse]
    def remove_user_id(user_id, request_options = {})
      response = remove_user_id_with_http_info(user_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::RemoveUserIdResponse")
    end

    # Replaces the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [Array<Source>] Allowed sources. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def replace_sources_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `replace_sources`."
      end

      path = "/1/security/sources"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source)

      new_options = request_options.merge(
        :operation => :"SearchClient.replace_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Replaces the list of allowed sources.
    #
    # Required API Key ACLs:
    #   - admin
    # @param source [Array<Source>] Allowed sources. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ReplaceSourceResponse]
    def replace_sources(source, request_options = {})
      response = replace_sources_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::ReplaceSourceResponse")
    end

    # Restores a deleted API key.  Restoring resets the `validity` attribute to `0`.  Algolia stores up to 1,000 API keys per application. If you create more, the oldest API keys are deleted and can't be restored.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def restore_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `restore_api_key`."
      end

      path = "/1/keys/{key}/restore".sub("{" + "key" + "}", Transport.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"SearchClient.restore_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Restores a deleted API key.  Restoring resets the `validity` attribute to `0`.  Algolia stores up to 1,000 API keys per application. If you create more, the oldest API keys are deleted and can't be restored.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AddApiKeyResponse]
    def restore_api_key(key, request_options = {})
      response = restore_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::AddApiKeyResponse")
    end

    # Adds a record to an index or replaces it.  - If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index. - If a record with the specified object ID exists, the existing record is replaced. - If a record with the specified object ID doesn't exist, a new record is added to your index. - If you add a record to an index that doesn't exist yet, a new index is created.  To update _some_ attributes of a record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject). To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param body [Object] The record. A schemaless object with attributes that are useful in the context of search and discovery. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_object_with_http_info(index_name, body, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_object`."
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Parameter `body` is required when calling `save_object`."
      end

      path = "/1/indexes/{indexName}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"SearchClient.save_object",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Adds a record to an index or replaces it.  - If the record doesn't have an object ID, a new record with an auto-generated object ID is added to your index. - If a record with the specified object ID exists, the existing record is replaced. - If a record with the specified object ID doesn't exist, a new record is added to your index. - If you add a record to an index that doesn't exist yet, a new index is created.  To update _some_ attributes of a record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject). To add, update, or replace multiple records, use the [`batch` operation](#tag/Records/operation/batch).  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - addObject
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param body [Object] The record. A schemaless object with attributes that are useful in the context of search and discovery. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SaveObjectResponse]
    def save_object(index_name, body, request_options = {})
      response = save_object_with_http_info(index_name, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SaveObjectResponse")
    end

    # If a rule with the specified object ID doesn't exist, it's created. Otherwise, the existing rule is replaced.  To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param rule [Rule]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_rule_with_http_info(index_name, algolia_object_id, rule, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_rule`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `save_rule`."
      end
      # verify the required parameter 'rule' is set
      if @api_client.config.client_side_validation && rule.nil?
        raise ArgumentError, "Parameter `rule` is required when calling `save_rule`."
      end

      path = "/1/indexes/{indexName}/rules/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(rule)

      new_options = request_options.merge(
        :operation => :"SearchClient.save_rule",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # If a rule with the specified object ID doesn't exist, it's created. Otherwise, the existing rule is replaced.  To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a rule object. (required)
    # @param rule [Rule]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def save_rule(index_name, algolia_object_id, rule, forward_to_replicas = nil, request_options = {})
      response = save_rule_with_http_info(index_name, algolia_object_id, rule, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Create or update multiple rules.  If a rule with the specified object ID doesn't exist, Algolia creates a new one. Otherwise, existing rules are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param rules [Array<Rule>]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param clear_existing_rules [Boolean] Whether existing rules should be deleted before adding this batch.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_rules_with_http_info(
      index_name,
      rules,
      forward_to_replicas = nil,
      clear_existing_rules = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_rules`."
      end
      # verify the required parameter 'rules' is set
      if @api_client.config.client_side_validation && rules.nil?
        raise ArgumentError, "Parameter `rules` is required when calling `save_rules`."
      end

      path = "/1/indexes/{indexName}/rules/batch".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params[:clearExistingRules] = clear_existing_rules unless clear_existing_rules.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(rules)

      new_options = request_options.merge(
        :operation => :"SearchClient.save_rules",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Create or update multiple rules.  If a rule with the specified object ID doesn't exist, Algolia creates a new one. Otherwise, existing rules are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param rules [Array<Rule>]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param clear_existing_rules [Boolean] Whether existing rules should be deleted before adding this batch.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def save_rules(index_name, rules, forward_to_replicas = nil, clear_existing_rules = nil, request_options = {})
      response = save_rules_with_http_info(
        index_name,
        rules,
        forward_to_replicas,
        clear_existing_rules,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # If a synonym with the specified object ID doesn't exist, Algolia adds a new one. Otherwise, the existing synonym is replaced. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param synonym_hit [SynonymHit]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_synonym_with_http_info(
      index_name,
      algolia_object_id,
      synonym_hit,
      forward_to_replicas = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_synonym`."
      end
      # verify the required parameter 'algolia_object_id' is set
      if @api_client.config.client_side_validation && algolia_object_id.nil?
        raise ArgumentError, "Parameter `algolia_object_id` is required when calling `save_synonym`."
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Parameter `synonym_hit` is required when calling `save_synonym`."
      end

      path = "/1/indexes/{indexName}/synonyms/{objectID}"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "objectID" + "}", Transport.encode_uri(algolia_object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      new_options = request_options.merge(
        :operation => :"SearchClient.save_synonym",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # If a synonym with the specified object ID doesn't exist, Algolia adds a new one. Otherwise, the existing synonym is replaced. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param algolia_object_id [String] Unique identifier of a synonym object. (required)
    # @param synonym_hit [SynonymHit]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SaveSynonymResponse]
    def save_synonym(index_name, algolia_object_id, synonym_hit, forward_to_replicas = nil, request_options = {})
      response = save_synonym_with_http_info(
        index_name,
        algolia_object_id,
        synonym_hit,
        forward_to_replicas,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SaveSynonymResponse")
    end

    # If a synonym with the `objectID` doesn't exist, Algolia adds a new one. Otherwise, existing synonyms are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param synonym_hit [Array<SynonymHit>]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param replace_existing_synonyms [Boolean] Whether to replace all synonyms in the index with the ones sent with this request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_synonyms_with_http_info(
      index_name,
      synonym_hit,
      forward_to_replicas = nil,
      replace_existing_synonyms = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_synonyms`."
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Parameter `synonym_hit` is required when calling `save_synonyms`."
      end

      path = "/1/indexes/{indexName}/synonyms/batch".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params[:replaceExistingSynonyms] = replace_existing_synonyms unless replace_existing_synonyms.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      new_options = request_options.merge(
        :operation => :"SearchClient.save_synonyms",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # If a synonym with the `objectID` doesn't exist, Algolia adds a new one. Otherwise, existing synonyms are replaced.  This operation is subject to [indexing rate limits](https://support.algolia.com/hc/en-us/articles/4406975251089-Is-there-a-rate-limit-for-indexing-on-Algolia).
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param synonym_hit [Array<SynonymHit>]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param replace_existing_synonyms [Boolean] Whether to replace all synonyms in the index with the ones sent with this request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def save_synonyms(
      index_name,
      synonym_hit,
      forward_to_replicas = nil,
      replace_existing_synonyms = nil,
      request_options = {}
    )
      response = save_synonyms_with_http_info(
        index_name,
        synonym_hit,
        forward_to_replicas,
        replace_existing_synonyms,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same indexfor example, with different filters.  Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.
    #
    # Required API Key ACLs:
    #   - search
    # @param search_method_params [SearchMethodParams] Muli-search request body. Results are returned in the same order as the requests. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_with_http_info(search_method_params, request_options = {})
      # verify the required parameter 'search_method_params' is set
      if @api_client.config.client_side_validation && search_method_params.nil?
        raise ArgumentError, "Parameter `search_method_params` is required when calling `search`."
      end

      path = "/1/indexes/*/queries"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_method_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Sends multiple search requests to one or more indices.  This can be useful in these cases:  - Different indices for different purposes, such as, one index for products, another one for marketing content. - Multiple searches to the same indexfor example, with different filters.  Use the helper `searchForHits` or `searchForFacets` to get the results in a more convenient format, if you already know the return type you want.
    #
    # Required API Key ACLs:
    #   - search
    # @param search_method_params [SearchMethodParams] Muli-search request body. Results are returned in the same order as the requests. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchResponses]
    def search(search_method_params, request_options = {})
      response = search_with_http_info(search_method_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SearchResponses")
    end

    # Searches for standard and custom dictionary entries.
    #
    # Required API Key ACLs:
    #   - settings
    # @param dictionary_name [DictionaryType] Dictionary type in which to search. (required)
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_dictionary_entries_with_http_info(
      dictionary_name,
      search_dictionary_entries_params,
      request_options = {}
    )
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Parameter `dictionary_name` is required when calling `search_dictionary_entries`."
      end
      # verify the required parameter 'search_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && search_dictionary_entries_params.nil?
        raise(
          ArgumentError,
          "Parameter `search_dictionary_entries_params` is required when calling `search_dictionary_entries`."
        )
      end

      path = "/1/dictionaries/{dictionaryName}/search".sub(
        "{" + "dictionaryName" + "}",
        Transport.encode_uri(dictionary_name.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_dictionary_entries_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_dictionary_entries",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for standard and custom dictionary entries.
    #
    # Required API Key ACLs:
    #   - settings
    # @param dictionary_name [DictionaryType] Dictionary type in which to search. (required)
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchDictionaryEntriesResponse]
    def search_dictionary_entries(dictionary_name, search_dictionary_entries_params, request_options = {})
      response = search_dictionary_entries_with_http_info(
        dictionary_name,
        search_dictionary_entries_params,
        request_options
      )
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::SearchDictionaryEntriesResponse"
      )
    end

    # Searches for values of a specified facet attribute.  - By default, facet values are sorted by decreasing count.   You can adjust this with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param facet_name [String] Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.  (required)
    # @param search_for_facet_values_request [SearchForFacetValuesRequest]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_for_facet_values_with_http_info(
      index_name,
      facet_name,
      search_for_facet_values_request = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_for_facet_values`."
      end
      # verify the required parameter 'facet_name' is set
      if @api_client.config.client_side_validation && facet_name.nil?
        raise ArgumentError, "Parameter `facet_name` is required when calling `search_for_facet_values`."
      end

      path = "/1/indexes/{indexName}/facets/{facetName}/query"
        .sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
        .sub("{" + "facetName" + "}", Transport.encode_uri(facet_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_for_facet_values_request)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_for_facet_values",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for values of a specified facet attribute.  - By default, facet values are sorted by decreasing count.   You can adjust this with the `sortFacetValueBy` parameter. - Searching for facet values doesn't work if you have **more than 65 searchable facets and searchable attributes combined**.
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param facet_name [String] Facet attribute in which to search for values.  This attribute must be included in the `attributesForFaceting` index setting with the `searchable()` modifier.  (required)
    # @param search_for_facet_values_request [SearchForFacetValuesRequest]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchForFacetValuesResponse]
    def search_for_facet_values(index_name, facet_name, search_for_facet_values_request = nil, request_options = {})
      response = search_for_facet_values_with_http_info(
        index_name,
        facet_name,
        search_for_facet_values_request,
        request_options
      )
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Search::SearchForFacetValuesResponse"
      )
    end

    # Searches for rules in your index.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_rules_params [SearchRulesParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_rules_with_http_info(index_name, search_rules_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_rules`."
      end

      path = "/1/indexes/{indexName}/rules/search".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_rules_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_rules",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for rules in your index.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_rules_params [SearchRulesParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchRulesResponse]
    def search_rules(index_name, search_rules_params = nil, request_options = {})
      response = search_rules_with_http_info(index_name, search_rules_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SearchRulesResponse")
    end

    # Searches a single index and returns matching search results (_hits_).  This method lets you retrieve up to 1,000 hits. If you need more, use the [`browse` operation](#tag/Search/operation/browse) or increase the `paginatedLimitedTo` index setting.
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_params [SearchParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_single_index_with_http_info(index_name, search_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_single_index`."
      end

      path = "/1/indexes/{indexName}/query".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_single_index",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches a single index and returns matching search results (_hits_).  This method lets you retrieve up to 1,000 hits. If you need more, use the [`browse` operation](#tag/Search/operation/browse) or increase the `paginatedLimitedTo` index setting.
    #
    # Required API Key ACLs:
    #   - search
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_params [SearchParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchResponse]
    def search_single_index(index_name, search_params = nil, request_options = {})
      response = search_single_index_with_http_info(index_name, search_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SearchResponse")
    end

    # Searches for synonyms in your index.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_synonyms_params [SearchSynonymsParams] Body of the `searchSynonyms` operation.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_synonyms_with_http_info(index_name, search_synonyms_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_synonyms`."
      end

      path = "/1/indexes/{indexName}/synonyms/search".sub(
        "{" + "indexName" + "}",
        Transport.encode_uri(index_name.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_synonyms_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_synonyms",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for synonyms in your index.
    #
    # Required API Key ACLs:
    #   - settings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param search_synonyms_params [SearchSynonymsParams] Body of the `searchSynonyms` operation.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchSynonymsResponse]
    def search_synonyms(index_name, search_synonyms_params = nil, request_options = {})
      response = search_synonyms_with_http_info(index_name, search_synonyms_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SearchSynonymsResponse")
    end

    # Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.  To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    #
    # Required API Key ACLs:
    #   - admin
    # THIS OPERATION IS DEPRECATED
    # @param search_user_ids_params [SearchUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_user_ids_with_http_info(search_user_ids_params, request_options = {})
      # verify the required parameter 'search_user_ids_params' is set
      if @api_client.config.client_side_validation && search_user_ids_params.nil?
        raise ArgumentError, "Parameter `search_user_ids_params` is required when calling `search_user_ids`."
      end

      path = "/1/clusters/mapping/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_user_ids_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.search_user_ids",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Since it can take a few seconds to get the data from the different clusters, the response isn't real-time.  To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    #
    # Required API Key ACLs:
    #   - admin
    # @param search_user_ids_params [SearchUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchUserIdsResponse]
    def search_user_ids(search_user_ids_params, request_options = {})
      response = search_user_ids_with_http_info(search_user_ids_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::SearchUserIdsResponse")
    end

    # Turns standard stop word dictionary entries on or off for a given language.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param dictionary_settings_params [DictionarySettingsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def set_dictionary_settings_with_http_info(dictionary_settings_params, request_options = {})
      # verify the required parameter 'dictionary_settings_params' is set
      if @api_client.config.client_side_validation && dictionary_settings_params.nil?
        raise(
          ArgumentError,
          "Parameter `dictionary_settings_params` is required when calling `set_dictionary_settings`."
        )
      end

      path = "/1/dictionaries/*/settings"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(dictionary_settings_params)

      new_options = request_options.merge(
        :operation => :"SearchClient.set_dictionary_settings",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Turns standard stop word dictionary entries on or off for a given language.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param dictionary_settings_params [DictionarySettingsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def set_dictionary_settings(dictionary_settings_params, request_options = {})
      response = set_dictionary_settings_with_http_info(dictionary_settings_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Update the specified index settings.  Index settings that you don't specify are left unchanged. Specify `null` to reset a setting to its default value.  For best performance, update the index settings before you add new records to your index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param index_settings [IndexSettings]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def set_settings_with_http_info(index_name, index_settings, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `set_settings`."
      end
      # verify the required parameter 'index_settings' is set
      if @api_client.config.client_side_validation && index_settings.nil?
        raise ArgumentError, "Parameter `index_settings` is required when calling `set_settings`."
      end

      path = "/1/indexes/{indexName}/settings".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(index_settings)

      new_options = request_options.merge(
        :operation => :"SearchClient.set_settings",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Update the specified index settings.  Index settings that you don't specify are left unchanged. Specify `null` to reset a setting to its default value.  For best performance, update the index settings before you add new records to your index.
    #
    # Required API Key ACLs:
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param index_settings [IndexSettings]  (required)
    # @param forward_to_replicas [Boolean] Whether changes are applied to replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def set_settings(index_name, index_settings, forward_to_replicas = nil, request_options = {})
      response = set_settings_with_http_info(index_name, index_settings, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdatedAtResponse")
    end

    # Replaces the permissions of an existing API key.  Any unspecified attribute resets that attribute to its default value.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_api_key_with_http_info(key, api_key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `update_api_key`."
      end
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Parameter `api_key` is required when calling `update_api_key`."
      end

      path = "/1/keys/{key}".sub("{" + "key" + "}", Transport.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(api_key)

      new_options = request_options.merge(
        :operation => :"SearchClient.update_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Replaces the permissions of an existing API key.  Any unspecified attribute resets that attribute to its default value.
    #
    # Required API Key ACLs:
    #   - admin
    # @param key [String] API key. (required)
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdateApiKeyResponse]
    def update_api_key(key, api_key, request_options = {})
      response = update_api_key_with_http_info(key, api_key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Search::UpdateApiKeyResponse")
    end

    # Helper: Wait for a task to be published (completed) for a given `index_name` and `task_id`.
    #
    # @param index_name [String] the `index_name` where the operation was performed. (required)
    # @param task_id [Integer] the `task_id` returned in the method response. (required)
    # @param max_retries [Integer] the maximum number of retries. (optional, default to 50)
    # @param timeout [Proc] the function to decide how long to wait between retries. (optional)
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `get_task` method.
    # @return [Http::Response] the last get_task response
    def wait_for_task(
      index_name,
      task_id,
      max_retries = 50,
      timeout = -> (retry_count) { [retry_count * 200, 5000].min },
      request_options = {}
    )
      retries = 0
      while retries < max_retries
        res = get_task(index_name, task_id, request_options)
        if res.status == "published"
          return res
        end

        retries += 1
        sleep(timeout.call(retries) / 1000.0)
      end

      raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
    end

    # Helper: Wait for an application-level task to be published (completed) for a given `task_id`.
    #
    # @param task_id [Integer] the `task_id` returned in the method response. (required)
    # @param max_retries [Integer] the maximum number of retries. (optional, default to 50)
    # @param timeout [Proc] the function to decide how long to wait between retries. (optional)
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `get_task` method.
    # @return [Http::Response] the last get_task response
    def wait_for_app_task(
      task_id,
      max_retries = 50,
      timeout = -> (retry_count) { [retry_count * 200, 5000].min },
      request_options = {}
    )
      retries = 0
      while retries < max_retries
        res = get_app_task(task_id, request_options)
        if res.status == "published"
          return res
        end

        retries += 1
        sleep(timeout.call(retries) / 1000.0)
      end

      raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
    end

    # Helper: Wait for an API key to be added, updated or deleted based on a given `operation`.
    #
    # @param key [String] the `key` that has been added, deleted or updated.
    # @param operation [String] the `operation` that was done on a `key`.
    # @param api_key [Hash] necessary to know if an `update` operation has been processed, compare fields of the response with it.
    # @param max_retries [Integer] the maximum number of retries.
    # @param timeout [Proc] the function to decide how long to wait between retries.
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `getApikey` method and merged with the transporter requestOptions.
    # @return [Http::Response] the last get_api_key response
    def wait_for_api_key(
      key,
      operation,
      api_key = Search::ApiKey.new,
      max_retries = 50,
      timeout = -> (retry_count) { [retry_count * 200, 5000].min },
      request_options = {}
    )
      api_key = api_client.object_to_hash(api_key)

      retries = 0
      if operation == "update"
        raise ArgumentError, "`api_key` is required when waiting for an `update` operation." if api_key.nil?
        while retries < max_retries
          updated_key = get_api_key(key, request_options)
          updated_key_hash = updated_key.to_hash
          equals = true
          api_key.each do |k, v|
            equals &&= updated_key_hash[k] == v
          end

          return updated_key if equals

          retries += 1
          sleep(timeout.call(retries) / 1000.0)
        end

        raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
      end

      while retries < max_retries
        begin
          res = get_api_key(key, request_options)
          return res if operation == "add"
        rescue AlgoliaHttpError => e
          if e.code == 404
            return nil if operation == "delete"
          else
            raise e
          end
        end

        retries += 1
        sleep(timeout.call(retries) / 1000.0)
      end

      raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
    end

    # Helper: Iterate on the `browse` method of the client to allow aggregating objects of an index.
    #
    # @param index_name [String] the `index_name` to browse. (required)
    # @param browse_params [BrowseParamsObject] the `browse_params` to send along with the query, they will be forwarded to the `browse` method.
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `browse` method.
    # @param block [Proc] the block to execute on each object of the index.
    def browse_objects(index_name, browse_params = Search::BrowseParamsObject.new, request_options = {}, &block)
      browse_params = api_client.object_to_hash(browse_params)

      browse_params[:hitsPerPage] = 1000 unless browse_params.key?(:hitsPerPage)

      hits = []
      loop do
        res = browse(index_name, browse_params, request_options)
        if block_given?
          res.hits.each do |hit|
            block.call(hit)
          end
        else
          hits.concat(res.hits)
        end

        browse_params[:cursor] = res.cursor
        break if browse_params[:cursor].nil?
      end

      hits unless block_given?
    end

    # Helper: Iterate on the `searchRules` method of the client to allow aggregating rules of an index.
    #
    # @param index_name [String] the `index_name` to browse rules from. (required)
    # @param search_rules_params [SearchRulesParams] the parameters to send along with the query, they will be forwarded to the `searchRules` method.
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `searchRules` method.
    # @param block [Proc] the block to execute on each rule of the index.
    def browse_rules(index_name, search_rules_params = Search::SearchRulesParams.new, request_options = {}, &block)
      search_rules_params = api_client.object_to_hash(search_rules_params)

      search_rules_params[:hitsPerPage] = 1000 unless search_rules_params.key?(:hitsPerPage)

      rules = []
      loop do
        res = search_rules(index_name, search_rules_params, request_options)
        if block_given?
          res.hits.each do |rule|
            block.call(rule)
          end
        else
          rules.concat(res.hits)
        end

        search_rules_params[:page] += 1
        break if res.hits.length < search_rules_params[:hitsPerPage]
      end

      rules unless block_given?
    end

    # Helper: Iterate on the `searchSynonyms` method of the client to allow aggregating synonyms of an index.
    #
    # @param index_name [String] the `index_name` to browse synonyms from. (required)
    # @param search_synonyms_params [SearchSynonymsParams] the parameters to send along with the query, they will be forwarded to the `searchSynonyms` method.
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `searchSynonyms` method.
    # @param block [Proc] the block to execute on each synonym of the index.
    def browse_synonyms(
      index_name,
      search_synonyms_params = Search::SearchSynonymsParams.new,
      request_options = {},
      &block
    )
      search_synonyms_params = api_client.object_to_hash(search_synonyms_params)

      search_synonyms_params[:hitsPerPage] = 1000 unless search_synonyms_params.key?(:hitsPerPage)

      synonyms = []
      loop do
        res = search_synonyms(index_name, search_synonyms_params, request_options)
        if block_given?
          res.hits.each do |synonym|
            block.call(synonym)
          end
        else
          synonyms.concat(res.hits)
        end

        search_synonyms_params[:page] += 1
        break if res.hits.length < search_synonyms_params[:hitsPerPage]
      end

      synonyms unless block_given?
    end

    # Helper: Generates a secured API key based on the given `parent_api_key` and given `restrictions`.
    #
    # @param parent_api_key [String] Parent API key used the generate the secured key
    # @param restrictions [SecuredApiKeyRestrictions] Restrictions to apply on the secured key
    #
    # @return [String]
    #
    def self.generate_secured_api_key(parent_api_key, restrictions = {})
      restrictions = restrictions.to_hash
      if restrictions.key?(:searchParams)
        # merge searchParams with the root of the restrictions

        restrictions.merge!(restrictions[:searchParams])
        restrictions.delete(:searchParams)
      end

      url_encoded_restrictions = Algolia::Transport
        .stringify_query_params(restrictions)
        .sort
        .to_h
        .map do |key, value|
          "#{key}=#{value}"
        end
        .join("&")

      hmac = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new("sha256"), parent_api_key, url_encoded_restrictions)
      Base64.encode64("#{hmac}#{url_encoded_restrictions}").gsub("\n", "")
    end

    # Helper: Generates a secured API key based on the given `parent_api_key` and given `restrictions`.
    #
    # @param parent_api_key [String] Parent API key used the generate the secured key
    # @param restrictions [SecuredApiKeyRestrictions] Restrictions to apply on the secured key
    #
    # @return [String]
    #
    def generate_secured_api_key(parent_api_key, restrictions = {})
      self.class.generate_secured_api_key(parent_api_key, restrictions)
    end

    # Helper: Retrieves the remaining validity of the previous generated `secured_api_key`, the `validUntil` parameter must have been provided.
    #
    # @param secured_api_key [String]
    #
    # @return [Integer]
    #
    def self.get_secured_api_key_remaining_validity(secured_api_key)
      now = Time.now.to_i
      decoded_key = Base64.decode64(secured_api_key)
      regex = "validUntil=(\\d+)"
      matches = decoded_key.match(regex)

      if matches.nil?
        raise AlgoliaError, "The SecuredApiKey doesn't have a validUntil parameter."
      end

      valid_until = matches[1].to_i

      valid_until - now
    end

    # Helper: Retrieves the remaining validity of the previous generated `secured_api_key`, the `validUntil` parameter must have been provided.
    #
    # @param secured_api_key [String]
    #
    # @return [Integer]
    #
    def get_secured_api_key_remaining_validity(secured_api_key)
      self.class.get_secured_api_key_remaining_validity(secured_api_key)
    end

    # Helper: Saves the given array of objects in the given index. The `chunked_batch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
    #
    # @param index_name [String]: The `index_name` to save `objects` in.
    # @param objects [Array]: The array of `objects` to store in the given Algolia `indexName`.
    # @param wait_for_tasks [Boolean]: Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
    # @param batch_size [int] The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    #
    # @return [BatchResponse]
    #
    def save_objects(index_name, objects, wait_for_tasks = false, batch_size = 1000, request_options = {})
      chunked_batch(
        index_name,
        objects,
        Search::Action::ADD_OBJECT,
        wait_for_tasks,
        batch_size,
        request_options
      )
    end

    # Helper: Deletes every records for the given objectIDs. The `chunked_batch` helper is used under the hood, which creates a `batch` requests with at most 1000 objectIDs in it.
    #
    # @param index_name [String]: The `index_name` to delete `object_ids` from.
    # @param object_ids [Array]: The object_ids to delete.
    # @param wait_for_tasks [Boolean]: Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
    # @param batch_size [int] The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    #
    # @return [BatchResponse]
    #
    def delete_objects(index_name, object_ids, wait_for_tasks = false, batch_size = 1000, request_options = {})
      chunked_batch(
        index_name,
        object_ids.map { |id| {"objectID" => id} },
        Search::Action::DELETE_OBJECT,
        wait_for_tasks,
        batch_size,
        request_options
      )
    end

    # Helper: Replaces object content of all the given objects according to their respective `object_id` field. The `chunkedBatch` helper is used under the hood, which creates a `batch` requests with at most 1000 objects in it.
    #
    # @param index_name [String]: The `index_name` to delete `object_ids` from.
    # @param objects [Array]: The objects to partially update.
    # @param create_if_not_exists [Boolean]: To be provided if non-existing objects are passed, otherwise, the call will fail.
    # @param wait_for_tasks [Boolean] Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
    # @param batch_size [int] The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    #
    # @return [BatchResponse]
    #
    def partial_update_objects(
      index_name,
      objects,
      create_if_not_exists,
      wait_for_tasks = false,
      batch_size = 1000,
      request_options = {}
    )
      chunked_batch(
        index_name,
        objects,
        create_if_not_exists ? Search::Action::PARTIAL_UPDATE_OBJECT : Search::Action::PARTIAL_UPDATE_OBJECT_NO_CREATE,
        wait_for_tasks,
        batch_size,
        request_options
      )
    end

    # Helper: Chunks the given `objects` list in subset of 1000 elements max in order to make it fit in `batch` requests.
    #
    # @param index_name [String] the `index_name` where the operation will be performed.
    # @param objects [Array] The array of `objects` to store in the given Algolia `index_name`.
    # @param action [Action] The `batch` `action` to perform on the given array of `objects`, defaults to `addObject`.
    # @param wait_for_tasks [Boolean] Whether or not we should wait until every `batch` tasks has been processed, this operation may slow the total execution time of this method but is more reliable.
    # @param batch_size [int] The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    #
    # @return [Array<BatchResponse>]
    #
    def chunked_batch(
      index_name,
      objects,
      action = Action::ADD_OBJECT,
      wait_for_tasks = false,
      batch_size = 1000,
      request_options = {}
    )
      responses = []
      objects.each_slice(batch_size) do |chunk|
        requests = chunk.map do |object|
          Search::BatchRequest.new(action: action, body: object)
        end

        responses.append(batch(index_name, Search::BatchWriteParams.new(requests: requests), request_options))
      end

      if wait_for_tasks
        responses.each do |response|
          wait_for_task(index_name, response.task_id)
        end
      end

      responses
    end

    # Helper: Replaces all objects (records) in the given `index_name` with the given `objects`. A temporary index is created during this process in order to backup your data.
    #
    # @param index_name [String] The `index_name` to replace `objects` in.
    # @param objects [Array] The array of `objects` to store in the given Algolia `index_name`.
    # @param batch_size [int] The size of the chunk of `objects`. The number of `batch` calls will be equal to `length(objects) / batchSize`. Defaults to 1000.
    # @param scopes [Array] The `scopes` to keep from the index. Defaults to `['settings', 'rules', 'synonyms']`.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    #
    # @return [Array<ReplaceAllObjectsResponse>]
    def replace_all_objects(
      index_name,
      objects,
      batch_size = 1000,
      scopes = [Search::ScopeType::SETTINGS, Search::ScopeType::RULES, Search::ScopeType::SYNONYMS],
      request_options = {}
    )
      tmp_index_name = index_name + "_tmp_" + rand(10_000_000).to_s

      begin
        copy_operation_response = operation_index(
          index_name,
          Search::OperationIndexParams.new(
            operation: Search::OperationType::COPY,
            destination: tmp_index_name,
            scope: scopes
          ),
          request_options
        )

        batch_responses = chunked_batch(
          tmp_index_name,
          objects,
          Search::Action::ADD_OBJECT,
          true,
          batch_size,
          request_options
        )

        wait_for_task(tmp_index_name, copy_operation_response.task_id)

        copy_operation_response = operation_index(
          index_name,
          Search::OperationIndexParams.new(
            operation: Search::OperationType::COPY,
            destination: tmp_index_name,
            scope: scopes
          ),
          request_options
        )

        wait_for_task(tmp_index_name, copy_operation_response.task_id)

        move_operation_response = operation_index(
          tmp_index_name,
          Search::OperationIndexParams.new(
            operation: Search::OperationType::MOVE,
            destination: index_name
          ),
          request_options
        )

        wait_for_task(tmp_index_name, move_operation_response.task_id)

        Search::ReplaceAllObjectsResponse.new(
          copy_operation_response: copy_operation_response,
          batch_responses: batch_responses,
          move_operation_response: move_operation_response
        )
      rescue Exception => e
        delete_index(tmp_index_name)

        raise e
      end
    end

    def index_exists?(index_name)
      begin
        get_settings(index_name)
      rescue Exception => e
        if e.is_a?(AlgoliaHttpError)
          return false if e.code == 404

          raise e
        end
      end

      true
    end
  end
end
