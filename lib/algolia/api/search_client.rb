# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

require 'cgi'

module Algolia
  class SearchClient
    attr_accessor :api_client

    def initialize(config = nil)
      @api_client = Algolia::ApiClient.new(config)
    end

    def self.create(app_id, api_key)
      hosts = []

      hosts << Transport::StatefulHost.new("#{app_id}-dsn.algolia.net", accept: CallType::READ)
      hosts << Transport::StatefulHost.new("#{app_id}.algolia.net", accept: CallType::WRITE)

      hosts += 1.upto(3).map do |i|
        Transport::StatefulHost.new("#{app_id}-#{i}.algolianet.com", accept: CallType::READ | CallType::WRITE)
      end.shuffle

      config = Algolia::Configuration.new(app_id, api_key, hosts, 'Search')
      create_with_config(config)
    end

    def self.create_with_config(config)
      new(config)
    end

    # Add API key.
    # Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
    # @param api_key [ApiKey]
    # @param [Hash] opts the optional parameters
    # @return [AddApiKeyResponse]
    def add_api_key(api_key, opts = {})
      data, _status_code, _headers = add_api_key_with_http_info(api_key, opts)
      data
    end

    # Add API key.
    # Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
    # @param api_key [ApiKey]
    # @param [Hash] opts the optional parameters
    # @return [Array<(AddApiKeyResponse, Integer, Hash)>] AddApiKeyResponse data, response status code and response headers
    def add_api_key_with_http_info(api_key, opts = {})
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Missing the required parameter 'api_key' when calling SearchClient.add_api_key"
      end

      path = '/1/keys'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(api_key)

      return_type = opts[:debug_return_type] || 'Search::AddApiKeyResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.add_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Add or update a record (using objectID).
    # If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param body [Object] Algolia record.
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtWithObjectIdResponse]
    def add_or_update_object(index_name, object_id, body, opts = {})
      data, _status_code, _headers = add_or_update_object_with_http_info(index_name, object_id, body, opts)
      data
    end

    # Add or update a record (using objectID).
    # If you use an existing &#x60;objectID&#x60;, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [&#x60;partial&#x60; operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param body [Object] Algolia record.
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtWithObjectIdResponse, Integer, Hash)>] UpdatedAtWithObjectIdResponse data, response status code and response headers
    def add_or_update_object_with_http_info(index_name, object_id, body, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.add_or_update_object"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.add_or_update_object"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Missing the required parameter 'body' when calling SearchClient.add_or_update_object"
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtWithObjectIdResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.add_or_update_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Add a source.
    # Add a source to the list of allowed sources.
    # @param source [Source] Source to add.
    # @param [Hash] opts the optional parameters
    # @return [CreatedAtResponse]
    def append_source(source, opts = {})
      data, _status_code, _headers = append_source_with_http_info(source, opts)
      data
    end

    # Add a source.
    # Add a source to the list of allowed sources.
    # @param source [Source] Source to add.
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedAtResponse, Integer, Hash)>] CreatedAtResponse data, response status code and response headers
    def append_source_with_http_info(source, opts = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Missing the required parameter 'source' when calling SearchClient.append_source"
      end

      path = '/1/security/sources/append'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(source)

      return_type = opts[:debug_return_type] || 'Search::CreatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.append_source',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Assign or move a user ID.
    # Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
    # @param x_algolia_user_id [String] userID to assign.
    # @param assign_user_id_params [AssignUserIdParams]
    # @param [Hash] opts the optional parameters
    # @return [CreatedAtResponse]
    def assign_user_id(x_algolia_user_id, assign_user_id_params, opts = {})
      data, _status_code, _headers = assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, opts)
      data
    end

    # Assign or move a user ID.
    # Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
    # @param x_algolia_user_id [String] userID to assign.
    # @param assign_user_id_params [AssignUserIdParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedAtResponse, Integer, Hash)>] CreatedAtResponse data, response status code and response headers
    def assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, opts = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Missing the required parameter 'x_algolia_user_id' when calling SearchClient.assign_user_id"
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && x_algolia_user_id !~ pattern
        raise ArgumentError, "invalid value for 'x_algolia_user_id' when calling SearchClient.assign_user_id, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'assign_user_id_params' is set
      if @api_client.config.client_side_validation && assign_user_id_params.nil?
        raise ArgumentError, "Missing the required parameter 'assign_user_id_params' when calling SearchClient.assign_user_id"
      end

      path = '/1/clusters/mapping'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}
      header_params[:X - Algolia - User - ID] = x_algolia_user_id

      post_body = opts[:debug_body] || @api_client.object_to_http_body(assign_user_id_params)

      return_type = opts[:debug_return_type] || 'Search::CreatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.assign_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch write operations on one index.
    # To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.
    # @param index_name [String] Index on which to perform the request.
    # @param batch_write_params [BatchWriteParams]
    # @param [Hash] opts the optional parameters
    # @return [BatchResponse]
    def batch(index_name, batch_write_params, opts = {})
      data, _status_code, _headers = batch_with_http_info(index_name, batch_write_params, opts)
      data
    end

    # Batch write operations on one index.
    # To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported &#x60;action&#x60;s are equivalent to the individual operations of the same name.
    # @param index_name [String] Index on which to perform the request.
    # @param batch_write_params [BatchWriteParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(BatchResponse, Integer, Hash)>] BatchResponse data, response status code and response headers
    def batch_with_http_info(index_name, batch_write_params, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.batch"
      end
      # verify the required parameter 'batch_write_params' is set
      if @api_client.config.client_side_validation && batch_write_params.nil?
        raise ArgumentError, "Missing the required parameter 'batch_write_params' when calling SearchClient.batch"
      end

      path = '/1/indexes/{indexName}/batch'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(batch_write_params)

      return_type = opts[:debug_return_type] || 'Search::BatchResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.batch',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch assign userIDs.
    # Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
    # @param x_algolia_user_id [String] userID to assign.
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]
    # @param [Hash] opts the optional parameters
    # @return [CreatedAtResponse]
    def batch_assign_user_ids(x_algolia_user_id, batch_assign_user_ids_params, opts = {})
      data, _status_code, _headers = batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, opts)
      data
    end

    # Batch assign userIDs.
    # Assign multiple user IDs to a cluster. **You can&#39;t _move_ users with this operation.**.
    # @param x_algolia_user_id [String] userID to assign.
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedAtResponse, Integer, Hash)>] CreatedAtResponse data, response status code and response headers
    def batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, opts = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Missing the required parameter 'x_algolia_user_id' when calling SearchClient.batch_assign_user_ids"
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && x_algolia_user_id !~ pattern
        raise ArgumentError, "invalid value for 'x_algolia_user_id' when calling SearchClient.batch_assign_user_ids, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'batch_assign_user_ids_params' is set
      if @api_client.config.client_side_validation && batch_assign_user_ids_params.nil?
        raise ArgumentError, "Missing the required parameter 'batch_assign_user_ids_params' when calling SearchClient.batch_assign_user_ids"
      end

      path = '/1/clusters/mapping/batch'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}
      header_params[:X - Algolia - User - ID] = x_algolia_user_id

      post_body = opts[:debug_body] || @api_client.object_to_http_body(batch_assign_user_ids_params)

      return_type = opts[:debug_return_type] || 'Search::CreatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.batch_assign_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch dictionary entries.
    # Add or remove a batch of dictionary entries.
    # @param dictionary_name [DictionaryType] Dictionary to search in.
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtResponse]
    def batch_dictionary_entries(dictionary_name, batch_dictionary_entries_params, opts = {})
      data, _status_code, _headers = batch_dictionary_entries_with_http_info(dictionary_name, batch_dictionary_entries_params, opts)
      data
    end

    # Batch dictionary entries.
    # Add or remove a batch of dictionary entries.
    # @param dictionary_name [DictionaryType] Dictionary to search in.
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def batch_dictionary_entries_with_http_info(dictionary_name, batch_dictionary_entries_params, opts = {})
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Missing the required parameter 'dictionary_name' when calling SearchClient.batch_dictionary_entries"
      end
      # verify the required parameter 'batch_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && batch_dictionary_entries_params.nil?
        raise ArgumentError, "Missing the required parameter 'batch_dictionary_entries_params' when calling SearchClient.batch_dictionary_entries"
      end

      path = '/1/dictionaries/{dictionaryName}/batch'.sub('{' + 'dictionaryName' + '}', CGI.escape(dictionary_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(batch_dictionary_entries_params)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.batch_dictionary_entries',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Get all records from an index.
    # Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [BrowseParams] :browse_params
    # @return [BrowseResponse]
    def browse(index_name, opts = {})
      data, _status_code, _headers = browse_with_http_info(index_name, opts)
      data
    end

    # Get all records from an index.
    # Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn&#39;t support: - The &#x60;distinct&#x60; query parameter - Sorting by typos, proximity, words, or geographical distance.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [BrowseParams] :browse_params
    # @return [Array<(BrowseResponse, Integer, Hash)>] BrowseResponse data, response status code and response headers
    def browse_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.browse"
      end

      path = '/1/indexes/{indexName}/browse'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:browse_params])

      return_type = opts[:debug_return_type] || 'Search::BrowseResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.browse',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all synonyms.
    # Delete all synonyms in the index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [UpdatedAtResponse]
    def clear_all_synonyms(index_name, opts = {})
      data, _status_code, _headers = clear_all_synonyms_with_http_info(index_name, opts)
      data
    end

    # Delete all synonyms.
    # Delete all synonyms in the index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def clear_all_synonyms_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.clear_all_synonyms"
      end

      path = '/1/indexes/{indexName}/synonyms/clear'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.clear_all_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all records from an index.
    # Delete the records but leave settings and index-specific API keys untouched.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtResponse]
    def clear_objects(index_name, opts = {})
      data, _status_code, _headers = clear_objects_with_http_info(index_name, opts)
      data
    end

    # Delete all records from an index.
    # Delete the records but leave settings and index-specific API keys untouched.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def clear_objects_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.clear_objects"
      end

      path = '/1/indexes/{indexName}/clear'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.clear_objects',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all rules.
    # Delete all rules in the index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [UpdatedAtResponse]
    def clear_rules(index_name, opts = {})
      data, _status_code, _headers = clear_rules_with_http_info(index_name, opts)
      data
    end

    # Delete all rules.
    # Delete all rules in the index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def clear_rules_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.clear_rules"
      end

      path = '/1/indexes/{indexName}/rules/clear'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.clear_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Object]
    def custom_delete(path, opts = {})
      data, _status_code, _headers = custom_delete_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_delete_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Missing the required parameter 'path' when calling SearchClient.custom_delete"
      end

      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:parameters] = opts[:parameters] unless opts[:parameters].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Object'

      new_options = opts.merge(
        :operation => :'SearchClient.custom_delete',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Object]
    def custom_get(path, opts = {})
      data, _status_code, _headers = custom_get_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_get_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Missing the required parameter 'path' when calling SearchClient.custom_get"
      end

      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:parameters] = opts[:parameters] unless opts[:parameters].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Object'

      new_options = opts.merge(
        :operation => :'SearchClient.custom_get',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Object]
    def custom_post(path, opts = {})
      data, _status_code, _headers = custom_post_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_post_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Missing the required parameter 'path' when calling SearchClient.custom_post"
      end

      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:parameters] = opts[:parameters] unless opts[:parameters].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:body])

      return_type = opts[:debug_return_type] || 'Search::Object'

      new_options = opts.merge(
        :operation => :'SearchClient.custom_post',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Object]
    def custom_put(path, opts = {})
      data, _status_code, _headers = custom_put_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_put_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Missing the required parameter 'path' when calling SearchClient.custom_put"
      end

      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:parameters] = opts[:parameters] unless opts[:parameters].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:body])

      return_type = opts[:debug_return_type] || 'Search::Object'

      new_options = opts.merge(
        :operation => :'SearchClient.custom_put',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Delete API key.
    # Delete an existing API key. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [DeleteApiKeyResponse]
    def delete_api_key(key, opts = {})
      data, _status_code, _headers = delete_api_key_with_http_info(key, opts)
      data
    end

    # Delete API key.
    # Delete an existing API key. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteApiKeyResponse, Integer, Hash)>] DeleteApiKeyResponse data, response status code and response headers
    def delete_api_key_with_http_info(key, opts = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Missing the required parameter 'key' when calling SearchClient.delete_api_key"
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', CGI.escape(key.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::DeleteApiKeyResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete all records matching a query.
    # This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.
    # @param index_name [String] Index on which to perform the request.
    # @param delete_by_params [DeleteByParams]
    # @param [Hash] opts the optional parameters
    # @return [DeletedAtResponse]
    def delete_by(index_name, delete_by_params, opts = {})
      data, _status_code, _headers = delete_by_with_http_info(index_name, delete_by_params, opts)
      data
    end

    # Delete all records matching a query.
    # This operation doesn&#39;t support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn&#39;t accept empty filters or queries.
    # @param index_name [String] Index on which to perform the request.
    # @param delete_by_params [DeleteByParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedAtResponse, Integer, Hash)>] DeletedAtResponse data, response status code and response headers
    def delete_by_with_http_info(index_name, delete_by_params, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.delete_by"
      end
      # verify the required parameter 'delete_by_params' is set
      if @api_client.config.client_side_validation && delete_by_params.nil?
        raise ArgumentError, "Missing the required parameter 'delete_by_params' when calling SearchClient.delete_by"
      end

      path = '/1/indexes/{indexName}/deleteByQuery'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(delete_by_params)

      return_type = opts[:debug_return_type] || 'Search::DeletedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_by',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete index.
    # Delete an existing index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [DeletedAtResponse]
    def delete_index(index_name, opts = {})
      data, _status_code, _headers = delete_index_with_http_info(index_name, opts)
      data
    end

    # Delete index.
    # Delete an existing index.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedAtResponse, Integer, Hash)>] DeletedAtResponse data, response status code and response headers
    def delete_index_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.delete_index"
      end

      path = '/1/indexes/{indexName}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::DeletedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a record.
    # To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param [Hash] opts the optional parameters
    # @return [DeletedAtResponse]
    def delete_object(index_name, object_id, opts = {})
      data, _status_code, _headers = delete_object_with_http_info(index_name, object_id, opts)
      data
    end

    # Delete a record.
    # To delete a set of records matching a query, use the [&#x60;deleteByQuery&#x60; operation](#tag/Records/operation/deleteBy) instead.
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeletedAtResponse, Integer, Hash)>] DeletedAtResponse data, response status code and response headers
    def delete_object_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.delete_object"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.delete_object"
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::DeletedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a rule.
    # Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [UpdatedAtResponse]
    def delete_rule(index_name, object_id, opts = {})
      data, _status_code, _headers = delete_rule_with_http_info(index_name, object_id, opts)
      data
    end

    # Delete a rule.
    # Delete a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def delete_rule_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.delete_rule"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.delete_rule"
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Remove a source.
    # Remove a source from the list of allowed sources.
    # @param source [String] IP address range of the source.
    # @param [Hash] opts the optional parameters
    # @return [DeleteSourceResponse]
    def delete_source(source, opts = {})
      data, _status_code, _headers = delete_source_with_http_info(source, opts)
      data
    end

    # Remove a source.
    # Remove a source from the list of allowed sources.
    # @param source [String] IP address range of the source.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteSourceResponse, Integer, Hash)>] DeleteSourceResponse data, response status code and response headers
    def delete_source_with_http_info(source, opts = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Missing the required parameter 'source' when calling SearchClient.delete_source"
      end

      path = '/1/security/sources/{source}'.sub('{' + 'source' + '}', CGI.escape(source.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::DeleteSourceResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_source',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a synonym.
    # Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [DeletedAtResponse]
    def delete_synonym(index_name, object_id, opts = {})
      data, _status_code, _headers = delete_synonym_with_http_info(index_name, object_id, opts)
      data
    end

    # Delete a synonym.
    # Delete a synonym by its &#x60;objectID&#x60;. To find the object IDs of your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(DeletedAtResponse, Integer, Hash)>] DeletedAtResponse data, response status code and response headers
    def delete_synonym_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.delete_synonym"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.delete_synonym"
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::DeletedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.delete_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Get API key permissions.
    # Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [GetApiKeyResponse]
    def get_api_key(key, opts = {})
      data, _status_code, _headers = get_api_key_with_http_info(key, opts)
      data
    end

    # Get API key permissions.
    # Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application&#39;s keys. When authenticating with other API keys, you can only retrieve information for that key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetApiKeyResponse, Integer, Hash)>] GetApiKeyResponse data, response status code and response headers
    def get_api_key_with_http_info(key, opts = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Missing the required parameter 'key' when calling SearchClient.get_api_key"
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', CGI.escape(key.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::GetApiKeyResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List available languages.
    # Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
    # @param [Hash] opts the optional parameters
    # @return [Hash<String, Languages>]
    def get_dictionary_languages(opts = {})
      data, _status_code, _headers = get_dictionary_languages_with_http_info(opts)
      data
    end

    # List available languages.
    # Lists Algolia&#39;s [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language&#39;s [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Hash<String, Languages>, Integer, Hash)>] Hash<String, Languages> data, response status code and response headers
    def get_dictionary_languages_with_http_info(opts = {})
      path = '/1/dictionaries/*/languages'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Hash<String, Languages>'

      new_options = opts.merge(
        :operation => :'SearchClient.get_dictionary_languages',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get stop word settings.
    # Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    # @param [Hash] opts the optional parameters
    # @return [GetDictionarySettingsResponse]
    def get_dictionary_settings(opts = {})
      data, _status_code, _headers = get_dictionary_settings_with_http_info(opts)
      data
    end

    # Get stop word settings.
    # Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetDictionarySettingsResponse, Integer, Hash)>] GetDictionarySettingsResponse data, response status code and response headers
    def get_dictionary_settings_with_http_info(opts = {})
      path = '/1/dictionaries/*/settings'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::GetDictionarySettingsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_dictionary_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Return the latest log entries.
    # The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (default to 0)
    # @option opts [Integer] :length Maximum number of entries to retrieve. (default to 10)
    # @option opts [String] :index_name Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
    # @option opts [LogType] :type Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to 'all')
    # @return [GetLogsResponse]
    def get_logs(opts = {})
      data, _status_code, _headers = get_logs_with_http_info(opts)
      data
    end

    # Return the latest log entries.
    # The request must be authenticated by an API key with the [&#x60;logs&#x60; ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There&#39;s also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn&#39;t appear in the logs itself. &gt; **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN&#39;s endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :offset First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (default to 0)
    # @option opts [Integer] :length Maximum number of entries to retrieve. (default to 10)
    # @option opts [String] :index_name Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
    # @option opts [LogType] :type Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to 'all')
    # @return [Array<(GetLogsResponse, Integer, Hash)>] GetLogsResponse data, response status code and response headers
    def get_logs_with_http_info(opts = {})
      if @api_client.config.client_side_validation && !opts[:length].nil? && opts[:length] > 1000
        raise ArgumentError, 'invalid value for "opts[:"length"]" when calling SearchClient.get_logs, must be smaller than or equal to 1000.'
      end

      path = '/1/logs'
      query_params = opts[:query_params] || {}
      query_params[:offset] = opts[:offset] unless opts[:offset].nil?
      query_params[:length] = opts[:length] unless opts[:length].nil?
      query_params[:indexName] = opts[:index_name] unless opts[:index_name].nil?
      query_params[:type] = opts[:type] unless opts[:type].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::GetLogsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_logs',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a record.
    # To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :attributes_to_retrieve Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won&#39;t be retrieved unless the request is authenticated with the admin API key.
    # @return [Hash<String, String>]
    def get_object(index_name, object_id, opts = {})
      data, _status_code, _headers = get_object_with_http_info(index_name, object_id, opts)
      data
    end

    # Get a record.
    # To get more than one record, use the [&#x60;objects&#x60; operation](#tag/Records/operation/getObjects).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :attributes_to_retrieve Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won&#39;t be retrieved unless the request is authenticated with the admin API key.
    # @return [Array<(Hash<String, String>, Integer, Hash)>] Hash<String, String> data, response status code and response headers
    def get_object_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.get_object"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.get_object"
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:attributesToRetrieve] = @api_client.build_collection_param(opts[:attributes_to_retrieve], :multi) unless opts[:attributes_to_retrieve].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Hash<String, String>'

      new_options = opts.merge(
        :operation => :'SearchClient.get_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get multiple records.
    # Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
    # @param get_objects_params [GetObjectsParams] Request object.
    # @param [Hash] opts the optional parameters
    # @return [GetObjectsResponse]
    def get_objects(get_objects_params, opts = {})
      data, _status_code, _headers = get_objects_with_http_info(get_objects_params, opts)
      data
    end

    # Get multiple records.
    # Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
    # @param get_objects_params [GetObjectsParams] Request object.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetObjectsResponse, Integer, Hash)>] GetObjectsResponse data, response status code and response headers
    def get_objects_with_http_info(get_objects_params, opts = {})
      # verify the required parameter 'get_objects_params' is set
      if @api_client.config.client_side_validation && get_objects_params.nil?
        raise ArgumentError, "Missing the required parameter 'get_objects_params' when calling SearchClient.get_objects"
      end

      path = '/1/indexes/*/objects'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(get_objects_params)

      return_type = opts[:debug_return_type] || 'Search::GetObjectsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_objects',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Get a rule.
    # Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param [Hash] opts the optional parameters
    # @return [Rule]
    def get_rule(index_name, object_id, opts = {})
      data, _status_code, _headers = get_rule_with_http_info(index_name, object_id, opts)
      data
    end

    # Get a rule.
    # Get a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Rule, Integer, Hash)>] Rule data, response status code and response headers
    def get_rule_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.get_rule"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.get_rule"
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Rule'

      new_options = opts.merge(
        :operation => :'SearchClient.get_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get index settings.
    # Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [IndexSettings]
    def get_settings(index_name, opts = {})
      data, _status_code, _headers = get_settings_with_http_info(index_name, opts)
      data
    end

    # Get index settings.
    # Return an object containing an index&#39;s [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @return [Array<(IndexSettings, Integer, Hash)>] IndexSettings data, response status code and response headers
    def get_settings_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.get_settings"
      end

      path = '/1/indexes/{indexName}/settings'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::IndexSettings'

      new_options = opts.merge(
        :operation => :'SearchClient.get_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get all allowed IP addresses.
    # Get all allowed sources (IP addresses).
    # @param [Hash] opts the optional parameters
    # @return [Array<Source>]
    def get_sources(opts = {})
      data, _status_code, _headers = get_sources_with_http_info(opts)
      data
    end

    # Get all allowed IP addresses.
    # Get all allowed sources (IP addresses).
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Source>, Integer, Hash)>] Array<Source> data, response status code and response headers
    def get_sources_with_http_info(opts = {})
      path = '/1/security/sources'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::Array<Source>'

      new_options = opts.merge(
        :operation => :'SearchClient.get_sources',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a synonym object.
    # Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param [Hash] opts the optional parameters
    # @return [SynonymHit]
    def get_synonym(index_name, object_id, opts = {})
      data, _status_code, _headers = get_synonym_with_http_info(index_name, object_id, opts)
      data
    end

    # Get a synonym object.
    # Get a syonym by its &#x60;objectID&#x60;. To find the object IDs for your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param [Hash] opts the optional parameters
    # @return [Array<(SynonymHit, Integer, Hash)>] SynonymHit data, response status code and response headers
    def get_synonym_with_http_info(index_name, object_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.get_synonym"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.get_synonym"
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::SynonymHit'

      new_options = opts.merge(
        :operation => :'SearchClient.get_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Check a task's status.
    # Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.
    # @param index_name [String] Index on which to perform the request.
    # @param task_id [Integer] Unique task identifier.
    # @param [Hash] opts the optional parameters
    # @return [GetTaskResponse]
    def get_task(index_name, task_id, opts = {})
      data, _status_code, _headers = get_task_with_http_info(index_name, task_id, opts)
      data
    end

    # Check a task&#39;s status.
    # Some operations, such as copying an index, will respond with a &#x60;taskID&#x60; value. Use this value here to check the status of that task.
    # @param index_name [String] Index on which to perform the request.
    # @param task_id [Integer] Unique task identifier.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetTaskResponse, Integer, Hash)>] GetTaskResponse data, response status code and response headers
    def get_task_with_http_info(index_name, task_id, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.get_task"
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Missing the required parameter 'task_id' when calling SearchClient.get_task"
      end

      path = '/1/indexes/{indexName}/task/{taskID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::GetTaskResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_task',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get top userID.
    # Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param [Hash] opts the optional parameters
    # @return [GetTopUserIdsResponse]
    def get_top_user_ids(opts = {})
      data, _status_code, _headers = get_top_user_ids_with_http_info(opts)
      data
    end

    # Get top userID.
    # Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param [Hash] opts the optional parameters
    # @return [Array<(GetTopUserIdsResponse, Integer, Hash)>] GetTopUserIdsResponse data, response status code and response headers
    def get_top_user_ids_with_http_info(opts = {})
      path = '/1/clusters/mapping/top'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::GetTopUserIdsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.get_top_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get userID.
    # Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param user_id [String] userID to assign.
    # @param [Hash] opts the optional parameters
    # @return [UserId]
    def get_user_id(user_id, opts = {})
      data, _status_code, _headers = get_user_id_with_http_info(user_id, opts)
      data
    end

    # Get userID.
    # Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param user_id [String] userID to assign.
    # @param [Hash] opts the optional parameters
    # @return [Array<(UserId, Integer, Hash)>] UserId data, response status code and response headers
    def get_user_id_with_http_info(user_id, opts = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Missing the required parameter 'user_id' when calling SearchClient.get_user_id"
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && user_id !~ pattern
        raise ArgumentError, "invalid value for 'user_id' when calling SearchClient.get_user_id, must conform to the pattern #{pattern}."
      end

      path = '/1/clusters/mapping/{userID}'.sub('{' + 'userID' + '}', CGI.escape(user_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::UserId'

      new_options = opts.merge(
        :operation => :'SearchClient.get_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get migration and user mapping status.
    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :get_clusters Indicates whether to include the cluster&#39;s pending mapping state in the response.
    # @return [HasPendingMappingsResponse]
    def has_pending_mappings(opts = {})
      data, _status_code, _headers = has_pending_mappings_with_http_info(opts)
      data
    end

    # Get migration and user mapping status.
    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :get_clusters Indicates whether to include the cluster&#39;s pending mapping state in the response.
    # @return [Array<(HasPendingMappingsResponse, Integer, Hash)>] HasPendingMappingsResponse data, response status code and response headers
    def has_pending_mappings_with_http_info(opts = {})
      path = '/1/clusters/mapping/pending'
      query_params = opts[:query_params] || {}
      query_params[:getClusters] = opts[:get_clusters] unless opts[:get_clusters].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::HasPendingMappingsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.has_pending_mappings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List API keys.
    # List all API keys associated with your Algolia application, including their permissions and restrictions.
    # @param [Hash] opts the optional parameters
    # @return [ListApiKeysResponse]
    def list_api_keys(opts = {})
      data, _status_code, _headers = list_api_keys_with_http_info(opts)
      data
    end

    # List API keys.
    # List all API keys associated with your Algolia application, including their permissions and restrictions.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListApiKeysResponse, Integer, Hash)>] ListApiKeysResponse data, response status code and response headers
    def list_api_keys_with_http_info(opts = {})
      path = '/1/keys'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::ListApiKeysResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.list_api_keys',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List clusters.
    # List the available clusters in a multi-cluster setup.
    # @param [Hash] opts the optional parameters
    # @return [ListClustersResponse]
    def list_clusters(opts = {})
      data, _status_code, _headers = list_clusters_with_http_info(opts)
      data
    end

    # List clusters.
    # List the available clusters in a multi-cluster setup.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ListClustersResponse, Integer, Hash)>] ListClustersResponse data, response status code and response headers
    def list_clusters_with_http_info(opts = {})
      path = '/1/clusters'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::ListClustersResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.list_clusters',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List indices.
    # List indices in an Algolia application.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @return [ListIndicesResponse]
    def list_indices(opts = {})
      data, _status_code, _headers = list_indices_with_http_info(opts)
      data
    end

    # List indices.
    # List indices in an Algolia application.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @return [Array<(ListIndicesResponse, Integer, Hash)>] ListIndicesResponse data, response status code and response headers
    def list_indices_with_http_info(opts = {})
      if @api_client.config.client_side_validation && !opts[:page].nil? && opts[:page] < 0
        raise ArgumentError, 'invalid value for "opts[:"page"]" when calling SearchClient.list_indices, must be greater than or equal to 0.'
      end

      path = '/1/indexes'
      query_params = opts[:query_params] || {}
      query_params[:page] = opts[:page] unless opts[:page].nil?
      query_params[:hitsPerPage] = opts[:hits_per_page] unless opts[:hits_per_page].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::ListIndicesResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.list_indices',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List userIDs.
    # List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @return [ListUserIdsResponse]
    def list_user_ids(opts = {})
      data, _status_code, _headers = list_user_ids_with_http_info(opts)
      data
    end

    # List userIDs.
    # List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :page Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @return [Array<(ListUserIdsResponse, Integer, Hash)>] ListUserIdsResponse data, response status code and response headers
    def list_user_ids_with_http_info(opts = {})
      if @api_client.config.client_side_validation && !opts[:page].nil? && opts[:page] < 0
        raise ArgumentError, 'invalid value for "opts[:"page"]" when calling SearchClient.list_user_ids, must be greater than or equal to 0.'
      end

      path = '/1/clusters/mapping'
      query_params = opts[:query_params] || {}
      query_params[:page] = opts[:page] unless opts[:page].nil?
      query_params[:hitsPerPage] = opts[:hits_per_page] unless opts[:hits_per_page].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::ListUserIdsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.list_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Batch write operations on multiple indices.
    # To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
    # @param batch_params [BatchParams]
    # @param [Hash] opts the optional parameters
    # @return [MultipleBatchResponse]
    def multiple_batch(batch_params, opts = {})
      data, _status_code, _headers = multiple_batch_with_http_info(batch_params, opts)
      data
    end

    # Batch write operations on multiple indices.
    # To reduce the time spent on network round trips, you can perform several write actions in a single request. It&#39;s a multi-index version of the [&#x60;batch&#x60; operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
    # @param batch_params [BatchParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(MultipleBatchResponse, Integer, Hash)>] MultipleBatchResponse data, response status code and response headers
    def multiple_batch_with_http_info(batch_params, opts = {})
      # verify the required parameter 'batch_params' is set
      if @api_client.config.client_side_validation && batch_params.nil?
        raise ArgumentError, "Missing the required parameter 'batch_params' when calling SearchClient.multiple_batch"
      end

      path = '/1/indexes/*/batch'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(batch_params)

      return_type = opts[:debug_return_type] || 'Search::MultipleBatchResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.multiple_batch',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Copy, move, or rename an index.
    # This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    # @param index_name [String] Index on which to perform the request.
    # @param operation_index_params [OperationIndexParams]
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtResponse]
    def operation_index(index_name, operation_index_params, opts = {})
      data, _status_code, _headers = operation_index_with_http_info(index_name, operation_index_params, opts)
      data
    end

    # Copy, move, or rename an index.
    # This &#x60;operation&#x60;, _copy_ or _move_, will copy or move a source index&#39;s (&#x60;IndexName&#x60;) records, settings, synonyms, and rules to a &#x60;destination&#x60; index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn&#39;t exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  &gt; **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    # @param index_name [String] Index on which to perform the request.
    # @param operation_index_params [OperationIndexParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def operation_index_with_http_info(index_name, operation_index_params, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.operation_index"
      end
      # verify the required parameter 'operation_index_params' is set
      if @api_client.config.client_side_validation && operation_index_params.nil?
        raise ArgumentError, "Missing the required parameter 'operation_index_params' when calling SearchClient.operation_index"
      end

      path = '/1/indexes/{indexName}/operation'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(operation_index_params)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.operation_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Update record attributes.
    # Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param attributes_to_update [Hash<String, AttributeToUpdate>] Object with attributes to update.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :create_if_not_exists Indicates whether to create a new record if it doesn&#39;t exist yet.  (default to true)
    # @return [UpdatedAtWithObjectIdResponse]
    def partial_update_object(index_name, object_id, attributes_to_update, opts = {})
      data, _status_code, _headers = partial_update_object_with_http_info(index_name, object_id, attributes_to_update, opts)
      data
    end

    # Update record attributes.
    # Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique record (object) identifier.
    # @param attributes_to_update [Hash<String, AttributeToUpdate>] Object with attributes to update.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :create_if_not_exists Indicates whether to create a new record if it doesn&#39;t exist yet.  (default to true)
    # @return [Array<(UpdatedAtWithObjectIdResponse, Integer, Hash)>] UpdatedAtWithObjectIdResponse data, response status code and response headers
    def partial_update_object_with_http_info(index_name, object_id, attributes_to_update, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.partial_update_object"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.partial_update_object"
      end
      # verify the required parameter 'attributes_to_update' is set
      if @api_client.config.client_side_validation && attributes_to_update.nil?
        raise ArgumentError, "Missing the required parameter 'attributes_to_update' when calling SearchClient.partial_update_object"
      end

      path = '/1/indexes/{indexName}/{objectID}/partial'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:createIfNotExists] = opts[:create_if_not_exists] unless opts[:create_if_not_exists].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(attributes_to_update)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtWithObjectIdResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.partial_update_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Remove userID.
    # Remove a userID and its associated data from the multi-clusters.
    # @param user_id [String] userID to assign.
    # @param [Hash] opts the optional parameters
    # @return [RemoveUserIdResponse]
    def remove_user_id(user_id, opts = {})
      data, _status_code, _headers = remove_user_id_with_http_info(user_id, opts)
      data
    end

    # Remove userID.
    # Remove a userID and its associated data from the multi-clusters.
    # @param user_id [String] userID to assign.
    # @param [Hash] opts the optional parameters
    # @return [Array<(RemoveUserIdResponse, Integer, Hash)>] RemoveUserIdResponse data, response status code and response headers
    def remove_user_id_with_http_info(user_id, opts = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Missing the required parameter 'user_id' when calling SearchClient.remove_user_id"
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && user_id !~ pattern
        raise ArgumentError, "invalid value for 'user_id' when calling SearchClient.remove_user_id, must conform to the pattern #{pattern}."
      end

      path = '/1/clusters/mapping/{userID}'.sub('{' + 'userID' + '}', CGI.escape(user_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::RemoveUserIdResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.remove_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Replace all sources.
    # Replace all allowed sources.
    # @param source [Array<Source>] Allowed sources.
    # @param [Hash] opts the optional parameters
    # @return [ReplaceSourceResponse]
    def replace_sources(source, opts = {})
      data, _status_code, _headers = replace_sources_with_http_info(source, opts)
      data
    end

    # Replace all sources.
    # Replace all allowed sources.
    # @param source [Array<Source>] Allowed sources.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ReplaceSourceResponse, Integer, Hash)>] ReplaceSourceResponse data, response status code and response headers
    def replace_sources_with_http_info(source, opts = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Missing the required parameter 'source' when calling SearchClient.replace_sources"
      end

      path = '/1/security/sources'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(source)

      return_type = opts[:debug_return_type] || 'Search::ReplaceSourceResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.replace_sources',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Restore API key.
    # Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [AddApiKeyResponse]
    def restore_api_key(key, opts = {})
      data, _status_code, _headers = restore_api_key_with_http_info(key, opts)
      data
    end

    # Restore API key.
    # Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param [Hash] opts the optional parameters
    # @return [Array<(AddApiKeyResponse, Integer, Hash)>] AddApiKeyResponse data, response status code and response headers
    def restore_api_key_with_http_info(key, opts = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Missing the required parameter 'key' when calling SearchClient.restore_api_key"
      end

      path = '/1/keys/{key}/restore'.sub('{' + 'key' + '}', CGI.escape(key.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Search::AddApiKeyResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.restore_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Add or update a record.
    # Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request.
    # @param body [Object] The Algolia record.
    # @param [Hash] opts the optional parameters
    # @return [SaveObjectResponse]
    def save_object(index_name, body, opts = {})
      data, _status_code, _headers = save_object_with_http_info(index_name, body, opts)
      data
    end

    # Add or update a record.
    # Add a record (object) to an index or replace it. If the record doesn&#39;t contain an &#x60;objectID&#x60;, Algolia automatically adds it. If you use an existing &#x60;objectID&#x60;, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request.
    # @param body [Object] The Algolia record.
    # @param [Hash] opts the optional parameters
    # @return [Array<(SaveObjectResponse, Integer, Hash)>] SaveObjectResponse data, response status code and response headers
    def save_object_with_http_info(index_name, body, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.save_object"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Missing the required parameter 'body' when calling SearchClient.save_object"
      end

      path = '/1/indexes/{indexName}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      return_type = opts[:debug_return_type] || 'Search::SaveObjectResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.save_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Create or update a rule.
    # To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param rule [Rule]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [UpdatedRuleResponse]
    def save_rule(index_name, object_id, rule, opts = {})
      data, _status_code, _headers = save_rule_with_http_info(index_name, object_id, rule, opts)
      data
    end

    # Create or update a rule.
    # To create or update more than one rule, use the [&#x60;batch&#x60; operation](#tag/Rules/operation/saveRules).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a rule object.
    # @param rule [Rule]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(UpdatedRuleResponse, Integer, Hash)>] UpdatedRuleResponse data, response status code and response headers
    def save_rule_with_http_info(index_name, object_id, rule, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.save_rule"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.save_rule"
      end
      # verify the required parameter 'rule' is set
      if @api_client.config.client_side_validation && rule.nil?
        raise ArgumentError, "Missing the required parameter 'rule' when calling SearchClient.save_rule"
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(rule)

      return_type = opts[:debug_return_type] || 'Search::UpdatedRuleResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.save_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Save a batch of rules.
    # Create or update multiple rules.
    # @param index_name [String] Index on which to perform the request.
    # @param rules [Array<Rule>]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @option opts [Boolean] :clear_existing_rules Indicates whether existing rules should be deleted before adding this batch.
    # @return [UpdatedAtResponse]
    def save_rules(index_name, rules, opts = {})
      data, _status_code, _headers = save_rules_with_http_info(index_name, rules, opts)
      data
    end

    # Save a batch of rules.
    # Create or update multiple rules.
    # @param index_name [String] Index on which to perform the request.
    # @param rules [Array<Rule>]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @option opts [Boolean] :clear_existing_rules Indicates whether existing rules should be deleted before adding this batch.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def save_rules_with_http_info(index_name, rules, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.save_rules"
      end
      # verify the required parameter 'rules' is set
      if @api_client.config.client_side_validation && rules.nil?
        raise ArgumentError, "Missing the required parameter 'rules' when calling SearchClient.save_rules"
      end

      path = '/1/indexes/{indexName}/rules/batch'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      query_params[:clearExistingRules] = opts[:clear_existing_rules] unless opts[:clear_existing_rules].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(rules)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.save_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Save a synonym.
    # Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param synonym_hit [SynonymHit]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [SaveSynonymResponse]
    def save_synonym(index_name, object_id, synonym_hit, opts = {})
      data, _status_code, _headers = save_synonym_with_http_info(index_name, object_id, synonym_hit, opts)
      data
    end

    # Save a synonym.
    # Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym &#x60;objectID&#x60; doesn&#39;t exist, Algolia adds a new one. If you use an existing synonym &#x60;objectID&#x60;, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [&#x60;batch&#x60; operation](#tag/Synonyms/operation/saveSynonyms).
    # @param index_name [String] Index on which to perform the request.
    # @param object_id [String] Unique identifier of a synonym object.
    # @param synonym_hit [SynonymHit]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(SaveSynonymResponse, Integer, Hash)>] SaveSynonymResponse data, response status code and response headers
    def save_synonym_with_http_info(index_name, object_id, synonym_hit, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.save_synonym"
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Missing the required parameter 'object_id' when calling SearchClient.save_synonym"
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Missing the required parameter 'synonym_hit' when calling SearchClient.save_synonym"
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'objectID' + '}', CGI.escape(object_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      return_type = opts[:debug_return_type] || 'Search::SaveSynonymResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.save_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Save a batch of synonyms.
    # Create or update multiple synonyms.
    # @param index_name [String] Index on which to perform the request.
    # @param synonym_hit [Array<SynonymHit>]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @option opts [Boolean] :replace_existing_synonyms Indicates whether to replace all synonyms in the index with the ones sent with this request.
    # @return [UpdatedAtResponse]
    def save_synonyms(index_name, synonym_hit, opts = {})
      data, _status_code, _headers = save_synonyms_with_http_info(index_name, synonym_hit, opts)
      data
    end

    # Save a batch of synonyms.
    # Create or update multiple synonyms.
    # @param index_name [String] Index on which to perform the request.
    # @param synonym_hit [Array<SynonymHit>]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @option opts [Boolean] :replace_existing_synonyms Indicates whether to replace all synonyms in the index with the ones sent with this request.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def save_synonyms_with_http_info(index_name, synonym_hit, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.save_synonyms"
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Missing the required parameter 'synonym_hit' when calling SearchClient.save_synonyms"
      end

      path = '/1/indexes/{indexName}/synonyms/batch'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      query_params[:replaceExistingSynonyms] = opts[:replace_existing_synonyms] unless opts[:replace_existing_synonyms].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.save_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search multiple indices.
    # Send multiple search queries to one or more indices.
    # @param search_method_params [SearchMethodParams] Query requests and strategies. Results will be received in the same order as the queries.
    # @param [Hash] opts the optional parameters
    # @return [SearchResponses]
    def search(search_method_params, opts = {})
      data, _status_code, _headers = search_with_http_info(search_method_params, opts)
      data
    end

    # Search multiple indices.
    # Send multiple search queries to one or more indices.
    # @param search_method_params [SearchMethodParams] Query requests and strategies. Results will be received in the same order as the queries.
    # @param [Hash] opts the optional parameters
    # @return [Array<(SearchResponses, Integer, Hash)>] SearchResponses data, response status code and response headers
    def search_with_http_info(search_method_params, opts = {})
      # verify the required parameter 'search_method_params' is set
      if @api_client.config.client_side_validation && search_method_params.nil?
        raise ArgumentError, "Missing the required parameter 'search_method_params' when calling SearchClient.search"
      end

      path = '/1/indexes/*/queries'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(search_method_params)

      return_type = opts[:debug_return_type] || 'Search::SearchResponses'

      new_options = opts.merge(
        :operation => :'SearchClient.search',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search dictionary entries.
    # Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
    # @param dictionary_name [DictionaryType] Dictionary to search in.
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtResponse]
    def search_dictionary_entries(dictionary_name, search_dictionary_entries_params, opts = {})
      data, _status_code, _headers = search_dictionary_entries_with_http_info(dictionary_name, search_dictionary_entries_params, opts)
      data
    end

    # Search dictionary entries.
    # Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
    # @param dictionary_name [DictionaryType] Dictionary to search in.
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def search_dictionary_entries_with_http_info(dictionary_name, search_dictionary_entries_params, opts = {})
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Missing the required parameter 'dictionary_name' when calling SearchClient.search_dictionary_entries"
      end
      # verify the required parameter 'search_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && search_dictionary_entries_params.nil?
        raise ArgumentError, "Missing the required parameter 'search_dictionary_entries_params' when calling SearchClient.search_dictionary_entries"
      end

      path = '/1/dictionaries/{dictionaryName}/search'.sub('{' + 'dictionaryName' + '}', CGI.escape(dictionary_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(search_dictionary_entries_params)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_dictionary_entries',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for facet values.
    # [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
    # @param index_name [String] Index on which to perform the request.
    # @param facet_name [String] Facet name.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchForFacetValuesRequest] :search_for_facet_values_request
    # @return [SearchForFacetValuesResponse]
    def search_for_facet_values(index_name, facet_name, opts = {})
      data, _status_code, _headers = search_for_facet_values_with_http_info(index_name, facet_name, opts)
      data
    end

    # Search for facet values.
    # [Search for a facet&#39;s values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. &gt; **Note**: Pagination isn&#39;t supported (&#x60;page&#x60; and &#x60;hitsPerPage&#x60; are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with &#x60;maxFacetHits&#x60;.
    # @param index_name [String] Index on which to perform the request.
    # @param facet_name [String] Facet name.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchForFacetValuesRequest] :search_for_facet_values_request
    # @return [Array<(SearchForFacetValuesResponse, Integer, Hash)>] SearchForFacetValuesResponse data, response status code and response headers
    def search_for_facet_values_with_http_info(index_name, facet_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.search_for_facet_values"
      end
      # verify the required parameter 'facet_name' is set
      if @api_client.config.client_side_validation && facet_name.nil?
        raise ArgumentError, "Missing the required parameter 'facet_name' when calling SearchClient.search_for_facet_values"
      end

      path = '/1/indexes/{indexName}/facets/{facetName}/query'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s)).sub('{' + 'facetName' + '}', CGI.escape(facet_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:search_for_facet_values_request])

      return_type = opts[:debug_return_type] || 'Search::SearchForFacetValuesResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_for_facet_values',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for rules.
    # Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchRulesParams] :search_rules_params
    # @return [SearchRulesResponse]
    def search_rules(index_name, opts = {})
      data, _status_code, _headers = search_rules_with_http_info(index_name, opts)
      data
    end

    # Search for rules.
    # Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchRulesParams] :search_rules_params
    # @return [Array<(SearchRulesResponse, Integer, Hash)>] SearchRulesResponse data, response status code and response headers
    def search_rules_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.search_rules"
      end

      path = '/1/indexes/{indexName}/rules/search'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:search_rules_params])

      return_type = opts[:debug_return_type] || 'Search::SearchRulesResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search an index.
    # Return records that match the query.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchParams] :search_params
    # @return [SearchResponse]
    def search_single_index(index_name, opts = {})
      data, _status_code, _headers = search_single_index_with_http_info(index_name, opts)
      data
    end

    # Search an index.
    # Return records that match the query.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SearchParams] :search_params
    # @return [Array<(SearchResponse, Integer, Hash)>] SearchResponse data, response status code and response headers
    def search_single_index_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.search_single_index"
      end

      path = '/1/indexes/{indexName}/query'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:search_params])

      return_type = opts[:debug_return_type] || 'Search::SearchResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_single_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for synonyms.
    # Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SynonymType] :type Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
    # @option opts [Integer] :page Returns the requested page number (the first page is 0). Page size is set by &#x60;hitsPerPage&#x60;. When null, there&#39;s no pagination.  (default to 0)
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @option opts [SearchSynonymsParams] :search_synonyms_params Body of the &#x60;searchSynonyms&#x60; operation.
    # @return [SearchSynonymsResponse]
    def search_synonyms(index_name, opts = {})
      data, _status_code, _headers = search_synonyms_with_http_info(index_name, opts)
      data
    end

    # Search for synonyms.
    # Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
    # @param index_name [String] Index on which to perform the request.
    # @param [Hash] opts the optional parameters
    # @option opts [SynonymType] :type Search for specific [types of synonyms](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms).
    # @option opts [Integer] :page Returns the requested page number (the first page is 0). Page size is set by &#x60;hitsPerPage&#x60;. When null, there&#39;s no pagination.  (default to 0)
    # @option opts [Integer] :hits_per_page Maximum number of hits per page. (default to 100)
    # @option opts [SearchSynonymsParams] :search_synonyms_params Body of the &#x60;searchSynonyms&#x60; operation.
    # @return [Array<(SearchSynonymsResponse, Integer, Hash)>] SearchSynonymsResponse data, response status code and response headers
    def search_synonyms_with_http_info(index_name, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.search_synonyms"
      end
      if @api_client.config.client_side_validation && !opts[:page].nil? && opts[:page] < 0
        raise ArgumentError, 'invalid value for "opts[:"page"]" when calling SearchClient.search_synonyms, must be greater than or equal to 0.'
      end

      path = '/1/indexes/{indexName}/synonyms/search'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:type] = opts[:type] unless opts[:type].nil?
      query_params[:page] = opts[:page] unless opts[:page].nil?
      query_params[:hitsPerPage] = opts[:hits_per_page] unless opts[:hits_per_page].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:search_synonyms_params])

      return_type = opts[:debug_return_type] || 'Search::SearchSynonymsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for a user ID.
    # Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    # @param search_user_ids_params [SearchUserIdsParams]
    # @param [Hash] opts the optional parameters
    # @return [SearchUserIdsResponse]
    def search_user_ids(search_user_ids_params, opts = {})
      data, _status_code, _headers = search_user_ids_with_http_info(search_user_ids_params, opts)
      data
    end

    # Search for a user ID.
    # Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. To ensure rapid updates, the user IDs index isn&#39;t built at the same time as the mapping. Instead, it&#39;s built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    # @param search_user_ids_params [SearchUserIdsParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(SearchUserIdsResponse, Integer, Hash)>] SearchUserIdsResponse data, response status code and response headers
    def search_user_ids_with_http_info(search_user_ids_params, opts = {})
      # verify the required parameter 'search_user_ids_params' is set
      if @api_client.config.client_side_validation && search_user_ids_params.nil?
        raise ArgumentError, "Missing the required parameter 'search_user_ids_params' when calling SearchClient.search_user_ids"
      end

      path = '/1/clusters/mapping/search'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(search_user_ids_params)

      return_type = opts[:debug_return_type] || 'Search::SearchUserIdsResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.search_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Set stop word settings.
    # Set stop word settings for a specific language.
    # @param dictionary_settings_params [DictionarySettingsParams]
    # @param [Hash] opts the optional parameters
    # @return [UpdatedAtResponse]
    def set_dictionary_settings(dictionary_settings_params, opts = {})
      data, _status_code, _headers = set_dictionary_settings_with_http_info(dictionary_settings_params, opts)
      data
    end

    # Set stop word settings.
    # Set stop word settings for a specific language.
    # @param dictionary_settings_params [DictionarySettingsParams]
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def set_dictionary_settings_with_http_info(dictionary_settings_params, opts = {})
      # verify the required parameter 'dictionary_settings_params' is set
      if @api_client.config.client_side_validation && dictionary_settings_params.nil?
        raise ArgumentError, "Missing the required parameter 'dictionary_settings_params' when calling SearchClient.set_dictionary_settings"
      end

      path = '/1/dictionaries/*/settings'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(dictionary_settings_params)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.set_dictionary_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Update index settings.
    # Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
    # @param index_name [String] Index on which to perform the request.
    # @param index_settings [IndexSettings]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [UpdatedAtResponse]
    def set_settings(index_name, index_settings, opts = {})
      data, _status_code, _headers = set_settings_with_http_info(index_name, index_settings, opts)
      data
    end

    # Update index settings.
    # Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
    # @param index_name [String] Index on which to perform the request.
    # @param index_settings [IndexSettings]
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :forward_to_replicas Indicates whether changed index settings are forwarded to the replica indices.
    # @return [Array<(UpdatedAtResponse, Integer, Hash)>] UpdatedAtResponse data, response status code and response headers
    def set_settings_with_http_info(index_name, index_settings, opts = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Missing the required parameter 'index_name' when calling SearchClient.set_settings"
      end
      # verify the required parameter 'index_settings' is set
      if @api_client.config.client_side_validation && index_settings.nil?
        raise ArgumentError, "Missing the required parameter 'index_settings' when calling SearchClient.set_settings"
      end

      path = '/1/indexes/{indexName}/settings'.sub('{' + 'indexName' + '}', CGI.escape(index_name.to_s))
      query_params = opts[:query_params] || {}
      query_params[:forwardToReplicas] = opts[:forward_to_replicas] unless opts[:forward_to_replicas].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(index_settings)

      return_type = opts[:debug_return_type] || 'Search::UpdatedAtResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.set_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Update an API key.
    # Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param api_key [ApiKey]
    # @param [Hash] opts the optional parameters
    # @return [UpdateApiKeyResponse]
    def update_api_key(key, api_key, opts = {})
      data, _status_code, _headers = update_api_key_with_http_info(key, api_key, opts)
      data
    end

    # Update an API key.
    # Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
    # @param key [String] API key.
    # @param api_key [ApiKey]
    # @param [Hash] opts the optional parameters
    # @return [Array<(UpdateApiKeyResponse, Integer, Hash)>] UpdateApiKeyResponse data, response status code and response headers
    def update_api_key_with_http_info(key, api_key, opts = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Missing the required parameter 'key' when calling SearchClient.update_api_key"
      end
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Missing the required parameter 'api_key' when calling SearchClient.update_api_key"
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', CGI.escape(key.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(api_key)

      return_type = opts[:debug_return_type] || 'Search::UpdateApiKeyResponse'

      new_options = opts.merge(
        :operation => :'SearchClient.update_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end
  end
end
