# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

module Algolia
  class SearchClient
    attr_accessor :api_client

    def initialize(config = nil)
      raise '`config` is missing.' if config.nil?
      raise '`app_id` is missing.' if config.app_id.nil? || config.app_id == ''
      raise '`api_key` is missing.' if config.api_key.nil? || config.api_key == ''

      @api_client = Algolia::ApiClient.new(config)
    end

    def self.create(app_id, api_key, opts = {})
      hosts = []
      hosts << Transport::StatefulHost.new("#{app_id}-dsn.algolia.net", accept: CallType::READ)
      hosts << Transport::StatefulHost.new("#{app_id}.algolia.net", accept: CallType::WRITE)

      hosts += 1.upto(3).map do |i|
        Transport::StatefulHost.new("#{app_id}-#{i}.algolianet.com", accept: CallType::READ | CallType::WRITE)
      end.shuffle

      config = Algolia::Configuration.new(app_id, api_key, hosts, 'Search', opts)
      create_with_config(config)
    end

    def self.create_with_config(config)
      new(config)
    end

    # Add API key.
    # Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def add_api_key_with_http_info(api_key, request_options = {})
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Parameter `api_key` is required when calling `add_api_key`."
      end

      path = '/1/keys'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(api_key)

      new_options = request_options.merge(
        :operation => :'SearchClient.add_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Add API key.
    # Add a new API key with specific permissions and restrictions. The request must be authenticated with the admin API key. The response returns an API key string.
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AddApiKeyResponse]
    def add_api_key(api_key, request_options = {})
      response = add_api_key_with_http_info(api_key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::AddApiKeyResponse')
    end

    # Add or update a record (using objectID).
    # If you use an existing &#x60;objectID&#x60;, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [&#x60;partial&#x60; operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param body [Object] Algolia record. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def add_or_update_object_with_http_info(index_name, object_id, body, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `add_or_update_object`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `add_or_update_object`."
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Parameter `body` is required when calling `add_or_update_object`."
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                           @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :'SearchClient.add_or_update_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Add or update a record (using objectID).
    # If you use an existing `objectID`, the existing record will be replaced with the new one.  To update only some attributes of an existing record, use the [`partial` operation](#tag/Records/operation/partialUpdateObject) instead.  To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param body [Object] Algolia record. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtWithObjectIdResponse]
    def add_or_update_object(index_name, object_id, body, request_options = {})
      response = add_or_update_object_with_http_info(index_name, object_id, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtWithObjectIdResponse')
    end

    # Add a source.
    # Add a source to the list of allowed sources.
    # @param source [Source] Source to add. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def append_source_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `append_source`."
      end

      path = '/1/security/sources/append'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source)

      new_options = request_options.merge(
        :operation => :'SearchClient.append_source',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Add a source.
    # Add a source to the list of allowed sources.
    # @param source [Source] Source to add. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def append_source(source, request_options = {})
      response = append_source_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::CreatedAtResponse')
    end

    # Assign or move a user ID.
    # Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
    # @param x_algolia_user_id [String] userID to assign. (required)
    # @param assign_user_id_params [AssignUserIdParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, request_options = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Parameter `x_algolia_user_id` is required when calling `assign_user_id`."
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && x_algolia_user_id !~ pattern
        raise ArgumentError, "invalid value for 'x_algolia_user_id' when calling SearchClient.assign_user_id, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'assign_user_id_params' is set
      if @api_client.config.client_side_validation && assign_user_id_params.nil?
        raise ArgumentError, "Parameter `assign_user_id_params` is required when calling `assign_user_id`."
      end

      path = '/1/clusters/mapping'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params[:'X-Algolia-User-ID'] = x_algolia_user_id
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(assign_user_id_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.assign_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Assign or move a user ID.
    # Assign or move a user ID to a cluster. The time it takes to move a user is proportional to the amount of data linked to the user ID.
    # @param x_algolia_user_id [String] userID to assign. (required)
    # @param assign_user_id_params [AssignUserIdParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def assign_user_id(x_algolia_user_id, assign_user_id_params, request_options = {})
      response = assign_user_id_with_http_info(x_algolia_user_id, assign_user_id_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::CreatedAtResponse')
    end

    # Batch write operations on one index.
    # To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported &#x60;action&#x60;s are equivalent to the individual operations of the same name.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param batch_write_params [BatchWriteParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_with_http_info(index_name, batch_write_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `batch`."
      end
      # verify the required parameter 'batch_write_params' is set
      if @api_client.config.client_side_validation && batch_write_params.nil?
        raise ArgumentError, "Parameter `batch_write_params` is required when calling `batch`."
      end

      path = '/1/indexes/{indexName}/batch'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_write_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.batch',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch write operations on one index.
    # To reduce the time spent on network round trips, you can perform several write actions in a single API call. Actions are applied in the order they are specified. The supported `action`s are equivalent to the individual operations of the same name.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param batch_write_params [BatchWriteParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [BatchResponse]
    def batch(index_name, batch_write_params, request_options = {})
      response = batch_with_http_info(index_name, batch_write_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::BatchResponse')
    end

    # Batch assign userIDs.
    # Assign multiple user IDs to a cluster. **You can&#39;t _move_ users with this operation.**.
    # @param x_algolia_user_id [String] userID to assign. (required)
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, request_options = {})
      # verify the required parameter 'x_algolia_user_id' is set
      if @api_client.config.client_side_validation && x_algolia_user_id.nil?
        raise ArgumentError, "Parameter `x_algolia_user_id` is required when calling `batch_assign_user_ids`."
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && x_algolia_user_id !~ pattern
        raise ArgumentError, "invalid value for 'x_algolia_user_id' when calling SearchClient.batch_assign_user_ids, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'batch_assign_user_ids_params' is set
      if @api_client.config.client_side_validation && batch_assign_user_ids_params.nil?
        raise ArgumentError, "Parameter `batch_assign_user_ids_params` is required when calling `batch_assign_user_ids`."
      end

      path = '/1/clusters/mapping/batch'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params[:'X-Algolia-User-ID'] = x_algolia_user_id
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_assign_user_ids_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.batch_assign_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch assign userIDs.
    # Assign multiple user IDs to a cluster. **You can't _move_ users with this operation.**.
    # @param x_algolia_user_id [String] userID to assign. (required)
    # @param batch_assign_user_ids_params [BatchAssignUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [CreatedAtResponse]
    def batch_assign_user_ids(x_algolia_user_id, batch_assign_user_ids_params, request_options = {})
      response = batch_assign_user_ids_with_http_info(x_algolia_user_id, batch_assign_user_ids_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::CreatedAtResponse')
    end

    # Batch dictionary entries.
    # Add or remove a batch of dictionary entries.
    # @param dictionary_name [DictionaryType] Dictionary to search in. (required)
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def batch_dictionary_entries_with_http_info(dictionary_name, batch_dictionary_entries_params, request_options = {})
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Parameter `dictionary_name` is required when calling `batch_dictionary_entries`."
      end
      # verify the required parameter 'batch_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && batch_dictionary_entries_params.nil?
        raise ArgumentError, "Parameter `batch_dictionary_entries_params` is required when calling `batch_dictionary_entries`."
      end

      path = '/1/dictionaries/{dictionaryName}/batch'.sub('{' + 'dictionaryName' + '}', @api_client.encode_uri(dictionary_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_dictionary_entries_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.batch_dictionary_entries',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch dictionary entries.
    # Add or remove a batch of dictionary entries.
    # @param dictionary_name [DictionaryType] Dictionary to search in. (required)
    # @param batch_dictionary_entries_params [BatchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def batch_dictionary_entries(dictionary_name, batch_dictionary_entries_params, request_options = {})
      response = batch_dictionary_entries_with_http_info(dictionary_name, batch_dictionary_entries_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Get all records from an index.
    # Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn&#39;t support: - The &#x60;distinct&#x60; query parameter - Sorting by typos, proximity, words, or geographical distance.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param browse_params [BrowseParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def browse_with_http_info(index_name, browse_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `browse`."
      end

      path = '/1/indexes/{indexName}/browse'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(browse_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.browse',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Get all records from an index.
    # Retrieve up to 1,000 records per call. Supports full-text search and filters. For better performance, it doesn't support: - The `distinct` query parameter - Sorting by typos, proximity, words, or geographical distance.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param browse_params [BrowseParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [BrowseResponse]
    def browse(index_name, browse_params = nil, request_options = {})
      response = browse_with_http_info(index_name, browse_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::BrowseResponse')
    end

    # Delete all records from an index.
    # Delete the records but leave settings and index-specific API keys untouched.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_objects_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_objects`."
      end

      path = '/1/indexes/{indexName}/clear'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.clear_objects',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all records from an index.
    # Delete the records but leave settings and index-specific API keys untouched.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_objects(index_name, request_options = {})
      response = clear_objects_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Delete all rules.
    # Delete all rules in the index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_rules_with_http_info(index_name, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_rules`."
      end

      path = '/1/indexes/{indexName}/rules/clear'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.clear_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all rules.
    # Delete all rules in the index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_rules(index_name, forward_to_replicas = nil, request_options = {})
      response = clear_rules_with_http_info(index_name, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Delete all synonyms.
    # Delete all synonyms in the index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def clear_synonyms_with_http_info(index_name, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `clear_synonyms`."
      end

      path = '/1/indexes/{indexName}/synonyms/clear'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.clear_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all synonyms.
    # Delete all synonyms in the index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def clear_synonyms(index_name, forward_to_replicas = nil, request_options = {})
      response = clear_synonyms_with_http_info(index_name, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_delete_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_delete`."
      end

      path = '/1{path}'.sub('{' + 'path' + '}', path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.custom_delete',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_delete(path, parameters = nil, request_options = {})
      response = custom_delete_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Object')
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_get_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_get`."
      end

      path = '/1{path}'.sub('{' + 'path' + '}', path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.custom_get',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_get(path, parameters = nil, request_options = {})
      response = custom_get_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Object')
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_post_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_post`."
      end

      path = '/1{path}'.sub('{' + 'path' + '}', path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :'SearchClient.custom_post',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_post(path, parameters = nil, body = nil, request_options = {})
      response = custom_post_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Object')
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_put_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_put`."
      end

      path = '/1{path}'.sub('{' + 'path' + '}', path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :'SearchClient.custom_put',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_put(path, parameters = nil, body = nil, request_options = {})
      response = custom_put_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Object')
    end

    # Delete API key.
    # Delete an existing API key. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `delete_api_key`."
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', @api_client.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete API key.
    # Delete an existing API key. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteApiKeyResponse]
    def delete_api_key(key, request_options = {})
      response = delete_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeleteApiKeyResponse')
    end

    # Delete all records matching a query.
    # This operation doesn&#39;t support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn&#39;t accept empty filters or queries.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param delete_by_params [DeleteByParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_by_with_http_info(index_name, delete_by_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_by`."
      end
      # verify the required parameter 'delete_by_params' is set
      if @api_client.config.client_side_validation && delete_by_params.nil?
        raise ArgumentError, "Parameter `delete_by_params` is required when calling `delete_by`."
      end

      path = '/1/indexes/{indexName}/deleteByQuery'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(delete_by_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_by',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Delete all records matching a query.
    # This operation doesn't support all the query options, only its filters (numeric, facet, or tag) and geo queries. It doesn't accept empty filters or queries.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param delete_by_params [DeleteByParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_by(index_name, delete_by_params, request_options = {})
      response = delete_by_with_http_info(index_name, delete_by_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeletedAtResponse')
    end

    # Delete index.
    # Delete an existing index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_index_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_index`."
      end

      path = '/1/indexes/{indexName}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete index.
    # Delete an existing index.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_index(index_name, request_options = {})
      response = delete_index_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeletedAtResponse')
    end

    # Delete a record.
    # To delete a set of records matching a query, use the [&#x60;deleteByQuery&#x60; operation](#tag/Records/operation/deleteBy) instead.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_object_with_http_info(index_name, object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_object`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `delete_object`."
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                           @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a record.
    # To delete a set of records matching a query, use the [`deleteByQuery` operation](#tag/Records/operation/deleteBy) instead.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_object(index_name, object_id, request_options = {})
      response = delete_object_with_http_info(index_name, object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeletedAtResponse')
    end

    # Delete a rule.
    # Delete a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_rule_with_http_info(index_name, object_id, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_rule`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `delete_rule`."
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                 @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a rule.
    # Delete a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def delete_rule(index_name, object_id, forward_to_replicas = nil, request_options = {})
      response = delete_rule_with_http_info(index_name, object_id, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Remove a source.
    # Remove a source from the list of allowed sources.
    # @param source [String] IP address range of the source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_source_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `delete_source`."
      end

      path = '/1/security/sources/{source}'.sub('{' + 'source' + '}', @api_client.encode_uri(source.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_source',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Remove a source.
    # Remove a source from the list of allowed sources.
    # @param source [String] IP address range of the source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteSourceResponse]
    def delete_source(source, request_options = {})
      response = delete_source_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeleteSourceResponse')
    end

    # Delete a synonym.
    # Delete a synonym by its &#x60;objectID&#x60;. To find the object IDs of your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_synonym_with_http_info(index_name, object_id, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `delete_synonym`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `delete_synonym`."
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                    @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.delete_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a synonym.
    # Delete a synonym by its `objectID`. To find the object IDs of your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeletedAtResponse]
    def delete_synonym(index_name, object_id, forward_to_replicas = nil, request_options = {})
      response = delete_synonym_with_http_info(index_name, object_id, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::DeletedAtResponse')
    end

    # Get API key permissions.
    # Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application&#39;s keys. When authenticating with other API keys, you can only retrieve information for that key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `get_api_key`."
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', @api_client.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get API key permissions.
    # Get the permissions and restrictions of a specific API key. When authenticating with the admin API key, you can request information for any of your application's keys. When authenticating with other API keys, you can only retrieve information for that key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetApiKeyResponse]
    def get_api_key(key, request_options = {})
      response = get_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetApiKeyResponse')
    end

    # List available languages.
    # Lists Algolia&#39;s [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language&#39;s [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_dictionary_languages_with_http_info(request_options = {})
      path = '/1/dictionaries/*/languages'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_dictionary_languages',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List available languages.
    # Lists Algolia's [supported languages](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/in-depth/supported-languages/) and any customizations applied to each language's [stop word](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plural](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), and [segmentation (compound)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) features.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Hash<String, Languages>]
    def get_dictionary_languages(request_options = {})
      response = get_dictionary_languages_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::Hash<String, Languages>')
    end

    # Get stop word settings.
    # Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_dictionary_settings_with_http_info(request_options = {})
      path = '/1/dictionaries/*/settings'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_dictionary_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get stop word settings.
    # Get the languages for which [stop words are turned off](#tag/Dictionaries/operation/setDictionarySettings).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetDictionarySettingsResponse]
    def get_dictionary_settings(request_options = {})
      response = get_dictionary_settings_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetDictionarySettingsResponse')
    end

    # Return the latest log entries.
    # The request must be authenticated by an API key with the [&#x60;logs&#x60; ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There&#39;s also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn&#39;t appear in the logs itself. &gt; **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN&#39;s endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    # @param offset [Integer] First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (default to 0)
    # @param length [Integer] Maximum number of entries to retrieve. (default to 10)
    # @param index_name [String] Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
    # @param type [LogType] Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to 'all')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_logs_with_http_info(offset = nil, length = nil, index_name = nil, type = nil, request_options = {})
      if @api_client.config.client_side_validation && !length.nil? && length > 1000
        raise ArgumentError, 'invalid value for ""length"" when calling SearchClient.get_logs, must be smaller than or equal to 1000.'
      end

      path = '/1/logs'
      query_params = {}
      query_params[:offset] = offset unless offset.nil?
      query_params[:length] = length unless length.nil?
      query_params[:indexName] = index_name unless index_name.nil?
      query_params[:type] = type unless type.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_logs',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Return the latest log entries.
    # The request must be authenticated by an API key with the [`logs` ACL](https://www.algolia.com/doc/guides/security/api-keys/#access-control-list-acl). Logs are held for the last seven days. There's also a logging limit of 1,000 API calls per server. This request counts towards your [operations quota](https://support.algolia.com/hc/en-us/articles/4406981829777-How-does-Algolia-count-records-and-operations-) but doesn't appear in the logs itself. > **Note**: To fetch the logs for a Distributed Search Network (DSN) cluster, target the [DSN's endpoint](https://www.algolia.com/doc/guides/scaling/distributed-search-network-dsn/#accessing-dsn-servers).
    # @param offset [Integer] First log entry to retrieve. Sorted by decreasing date with 0 being the most recent. (default to 0)
    # @param length [Integer] Maximum number of entries to retrieve. (default to 10)
    # @param index_name [String] Index for which log entries should be retrieved. When omitted, log entries are retrieved for all indices.
    # @param type [LogType] Type of log entries to retrieve. When omitted, all log entries are retrieved. (default to 'all')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetLogsResponse]
    def get_logs(offset = nil, length = nil, index_name = nil, type = nil, request_options = {})
      response = get_logs_with_http_info(offset, length, index_name, type, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetLogsResponse')
    end

    # Get a record.
    # To get more than one record, use the [&#x60;objects&#x60; operation](#tag/Records/operation/getObjects).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param attributes_to_retrieve [Array<String>] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won&#39;t be retrieved unless the request is authenticated with the admin API key.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_object_with_http_info(index_name, object_id, attributes_to_retrieve = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_object`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `get_object`."
      end

      path = '/1/indexes/{indexName}/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                           @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:attributesToRetrieve] = @api_client.build_collection_param(attributes_to_retrieve, :multi) unless attributes_to_retrieve.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a record.
    # To get more than one record, use the [`objects` operation](#tag/Records/operation/getObjects).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param attributes_to_retrieve [Array<String>] Attributes to include with the records in the response. This is useful to reduce the size of the API response. By default, all retrievable attributes are returned. &#x60;objectID&#x60; is always retrieved, even when not specified. [&#x60;unretrievableAttributes&#x60;](https://www.algolia.com/doc/api-reference/api-parameters/unretrievableAttributes/) won&#39;t be retrieved unless the request is authenticated with the admin API key.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Hash<String, String>]
    def get_object(index_name, object_id, attributes_to_retrieve = nil, request_options = {})
      response = get_object_with_http_info(index_name, object_id, attributes_to_retrieve, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::Hash<String, String>')
    end

    # Get multiple records.
    # Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
    # @param get_objects_params [GetObjectsParams] Request object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_objects_with_http_info(get_objects_params, request_options = {})
      # verify the required parameter 'get_objects_params' is set
      if @api_client.config.client_side_validation && get_objects_params.nil?
        raise ArgumentError, "Parameter `get_objects_params` is required when calling `get_objects`."
      end

      path = '/1/indexes/*/objects'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(get_objects_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.get_objects',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Get multiple records.
    # Retrieve one or more records, potentially from different indices, in a single API operation. Results will be received in the same order as the requests.
    # @param get_objects_params [GetObjectsParams] Request object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetObjectsResponse]
    def get_objects(get_objects_params, request_options = {})
      response = get_objects_with_http_info(get_objects_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetObjectsResponse')
    end

    # Get a rule.
    # Get a rule by its &#x60;objectID&#x60;. To find the &#x60;objectID&#x60; for rules, use the [&#x60;search&#x60; operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_rule_with_http_info(index_name, object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_rule`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `get_rule`."
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                 @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a rule.
    # Get a rule by its `objectID`. To find the `objectID` for rules, use the [`search` operation](#tag/Rules/operation/searchRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Rule]
    def get_rule(index_name, object_id, request_options = {})
      response = get_rule_with_http_info(index_name, object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::Rule')
    end

    # Get index settings.
    # Return an object containing an index&#39;s [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_settings_with_http_info(index_name, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_settings`."
      end

      path = '/1/indexes/{indexName}/settings'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get index settings.
    # Return an object containing an index's [configuration settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [IndexSettings]
    def get_settings(index_name, request_options = {})
      response = get_settings_with_http_info(index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::IndexSettings')
    end

    # Get all allowed IP addresses.
    # Get all allowed sources (IP addresses).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_sources_with_http_info(request_options = {})
      path = '/1/security/sources'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_sources',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get all allowed IP addresses.
    # Get all allowed sources (IP addresses).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Source>]
    def get_sources(request_options = {})
      response = get_sources_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Array<Search::Source>')
    end

    # Get a synonym object.
    # Get a syonym by its &#x60;objectID&#x60;. To find the object IDs for your synonyms, use the [&#x60;search&#x60; operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_synonym_with_http_info(index_name, object_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_synonym`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `get_synonym`."
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                    @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a synonym object.
    # Get a syonym by its `objectID`. To find the object IDs for your synonyms, use the [`search` operation](#tag/Synonyms/operation/searchSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SynonymHit]
    def get_synonym(index_name, object_id, request_options = {})
      response = get_synonym_with_http_info(index_name, object_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SynonymHit')
    end

    # Check a task&#39;s status.
    # Some operations, such as copying an index, will respond with a &#x60;taskID&#x60; value. Use this value here to check the status of that task.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_task_with_http_info(index_name, task_id, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `get_task`."
      end
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `get_task`."
      end

      path = '/1/indexes/{indexName}/task/{taskID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'taskID' + '}',
                                                                                                                              @api_client.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_task',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Check a task's status.
    # Some operations, such as copying an index, will respond with a `taskID` value. Use this value here to check the status of that task.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param task_id [Integer] Unique task identifier. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetTaskResponse]
    def get_task(index_name, task_id, request_options = {})
      response = get_task_with_http_info(index_name, task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetTaskResponse')
    end

    # Get top userID.
    # Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_top_user_ids_with_http_info(request_options = {})
      path = '/1/clusters/mapping/top'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_top_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get top userID.
    # Get the IDs of the 10 users with the highest number of records per cluster. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [GetTopUserIdsResponse]
    def get_top_user_ids(request_options = {})
      response = get_top_user_ids_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::GetTopUserIdsResponse')
    end

    # Get userID.
    # Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param user_id [String] userID to assign. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_user_id_with_http_info(user_id, request_options = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Parameter `user_id` is required when calling `get_user_id`."
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && user_id !~ pattern
        raise ArgumentError, "invalid value for 'user_id' when calling SearchClient.get_user_id, must conform to the pattern #{pattern}."
      end

      path = '/1/clusters/mapping/{userID}'.sub('{' + 'userID' + '}', @api_client.encode_uri(user_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.get_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get userID.
    # Returns the userID data stored in the mapping. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param user_id [String] userID to assign. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UserId]
    def get_user_id(user_id, request_options = {})
      response = get_user_id_with_http_info(user_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UserId')
    end

    # Get migration and user mapping status.
    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    # @param get_clusters [Boolean] Indicates whether to include the cluster&#39;s pending mapping state in the response.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def has_pending_mappings_with_http_info(get_clusters = nil, request_options = {})
      path = '/1/clusters/mapping/pending'
      query_params = {}
      query_params[:getClusters] = get_clusters unless get_clusters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.has_pending_mappings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get migration and user mapping status.
    # To determine when the time-consuming process of creating a large batch of users or migrating users from one cluster to another is complete, this operation retrieves the status of the process.
    # @param get_clusters [Boolean] Indicates whether to include the cluster&#39;s pending mapping state in the response.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [HasPendingMappingsResponse]
    def has_pending_mappings(get_clusters = nil, request_options = {})
      response = has_pending_mappings_with_http_info(get_clusters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::HasPendingMappingsResponse')
    end

    # List API keys.
    # List all API keys associated with your Algolia application, including their permissions and restrictions.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_api_keys_with_http_info(request_options = {})
      path = '/1/keys'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.list_api_keys',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List API keys.
    # List all API keys associated with your Algolia application, including their permissions and restrictions.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListApiKeysResponse]
    def list_api_keys(request_options = {})
      response = list_api_keys_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::ListApiKeysResponse')
    end

    # List clusters.
    # List the available clusters in a multi-cluster setup.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_clusters_with_http_info(request_options = {})
      path = '/1/clusters'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.list_clusters',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List clusters.
    # List the available clusters in a multi-cluster setup.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListClustersResponse]
    def list_clusters(request_options = {})
      response = list_clusters_with_http_info(request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::ListClustersResponse')
    end

    # List indices.
    # List indices in an Algolia application.
    # @param page [Integer] Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @param hits_per_page [Integer] Maximum number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_indices_with_http_info(page = nil, hits_per_page = nil, request_options = {})
      if @api_client.config.client_side_validation && !page.nil? && page < 0
        raise ArgumentError, 'invalid value for ""page"" when calling SearchClient.list_indices, must be greater than or equal to 0.'
      end

      path = '/1/indexes'
      query_params = {}
      query_params[:page] = page unless page.nil?
      query_params[:hitsPerPage] = hits_per_page unless hits_per_page.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.list_indices',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List indices.
    # List indices in an Algolia application.
    # @param page [Integer] Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @param hits_per_page [Integer] Maximum number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListIndicesResponse]
    def list_indices(page = nil, hits_per_page = nil, request_options = {})
      response = list_indices_with_http_info(page, hits_per_page, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::ListIndicesResponse')
    end

    # List userIDs.
    # List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time.
    # @param page [Integer] Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @param hits_per_page [Integer] Maximum number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_user_ids_with_http_info(page = nil, hits_per_page = nil, request_options = {})
      if @api_client.config.client_side_validation && !page.nil? && page < 0
        raise ArgumentError, 'invalid value for ""page"" when calling SearchClient.list_user_ids, must be greater than or equal to 0.'
      end

      path = '/1/clusters/mapping'
      query_params = {}
      query_params[:page] = page unless page.nil?
      query_params[:hitsPerPage] = hits_per_page unless hits_per_page.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.list_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # List userIDs.
    # List the userIDs assigned to a multi-cluster application. Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time.
    # @param page [Integer] Returns the requested page number. The page size is determined by the &#x60;hitsPerPage&#x60; parameter. You can see the number of available pages in the &#x60;nbPages&#x60; response attribute. When &#x60;page&#x60; is null, the API response is not paginated.
    # @param hits_per_page [Integer] Maximum number of hits per page. (default to 100)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListUserIdsResponse]
    def list_user_ids(page = nil, hits_per_page = nil, request_options = {})
      response = list_user_ids_with_http_info(page, hits_per_page, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::ListUserIdsResponse')
    end

    # Batch write operations on multiple indices.
    # To reduce the time spent on network round trips, you can perform several write actions in a single request. It&#39;s a multi-index version of the [&#x60;batch&#x60; operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
    # @param batch_params [BatchParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def multiple_batch_with_http_info(batch_params, request_options = {})
      # verify the required parameter 'batch_params' is set
      if @api_client.config.client_side_validation && batch_params.nil?
        raise ArgumentError, "Parameter `batch_params` is required when calling `multiple_batch`."
      end

      path = '/1/indexes/*/batch'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(batch_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.multiple_batch',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Batch write operations on multiple indices.
    # To reduce the time spent on network round trips, you can perform several write actions in a single request. It's a multi-index version of the [`batch` operation](#tag/Records/operation/batch). Actions are applied in the order they are specified. The supported actions are equivalent to the individual operations of the same name.
    # @param batch_params [BatchParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [MultipleBatchResponse]
    def multiple_batch(batch_params, request_options = {})
      response = multiple_batch_with_http_info(batch_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::MultipleBatchResponse')
    end

    # Copy, move, or rename an index.
    # This &#x60;operation&#x60;, _copy_ or _move_, will copy or move a source index&#39;s (&#x60;IndexName&#x60;) records, settings, synonyms, and rules to a &#x60;destination&#x60; index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn&#39;t exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  &gt; **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param operation_index_params [OperationIndexParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def operation_index_with_http_info(index_name, operation_index_params, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `operation_index`."
      end
      # verify the required parameter 'operation_index_params' is set
      if @api_client.config.client_side_validation && operation_index_params.nil?
        raise ArgumentError, "Parameter `operation_index_params` is required when calling `operation_index`."
      end

      path = '/1/indexes/{indexName}/operation'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(operation_index_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.operation_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Copy, move, or rename an index.
    # This `operation`, _copy_ or _move_, will copy or move a source index's (`IndexName`) records, settings, synonyms, and rules to a `destination` index. If the destination index exists, it will be replaced, except for index-specific API keys and analytics data. If the destination index doesn't exist, it will be created.  The choice between moving or copying an index depends on your needs. Choose:  - **Move** to rename an index. - **Copy** to create a new index with the same records and configuration as an existing one.  > **Note**: When considering copying or moving, be aware of the [rate limitations](https://www.algolia.com/doc/guides/scaling/algolia-service-limits/#application-record-and-index-limits) on these processes and the [impact on your analytics data](https://www.algolia.com/doc/guides/sending-and-managing-data/manage-indices-and-apps/manage-indices/concepts/indices-analytics/).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param operation_index_params [OperationIndexParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def operation_index(index_name, operation_index_params, request_options = {})
      response = operation_index_with_http_info(index_name, operation_index_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Update record attributes.
    # Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param attributes_to_update [Hash<String, AttributeToUpdate>] Object with attributes to update. (required)
    # @param create_if_not_exists [Boolean] Indicates whether to create a new record if it doesn&#39;t exist yet.  (default to true)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def partial_update_object_with_http_info(index_name, object_id, attributes_to_update, create_if_not_exists = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `partial_update_object`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `partial_update_object`."
      end
      # verify the required parameter 'attributes_to_update' is set
      if @api_client.config.client_side_validation && attributes_to_update.nil?
        raise ArgumentError, "Parameter `attributes_to_update` is required when calling `partial_update_object`."
      end

      path = '/1/indexes/{indexName}/{objectID}/partial'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                   @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:createIfNotExists] = create_if_not_exists unless create_if_not_exists.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(attributes_to_update)

      new_options = request_options.merge(
        :operation => :'SearchClient.partial_update_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Update record attributes.
    # Add new attributes or update current ones in an existing record. You can use any first-level attribute but not nested attributes. If you specify a [nested attribute](https://www.algolia.com/doc/guides/sending-and-managing-data/prepare-your-data/how-to/creating-and-using-nested-attributes/), the engine treats it as a replacement for its first-level ancestor.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique record (object) identifier. (required)
    # @param attributes_to_update [Hash<String, AttributeToUpdate>] Object with attributes to update. (required)
    # @param create_if_not_exists [Boolean] Indicates whether to create a new record if it doesn&#39;t exist yet.  (default to true)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtWithObjectIdResponse]
    def partial_update_object(index_name, object_id, attributes_to_update, create_if_not_exists = nil, request_options = {})
      response = partial_update_object_with_http_info(index_name, object_id, attributes_to_update, create_if_not_exists, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtWithObjectIdResponse')
    end

    # Remove userID.
    # Remove a userID and its associated data from the multi-clusters.
    # @param user_id [String] userID to assign. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def remove_user_id_with_http_info(user_id, request_options = {})
      # verify the required parameter 'user_id' is set
      if @api_client.config.client_side_validation && user_id.nil?
        raise ArgumentError, "Parameter `user_id` is required when calling `remove_user_id`."
      end

      pattern = /^[a-zA-Z0-9 \-*.]+$/
      if @api_client.config.client_side_validation && user_id !~ pattern
        raise ArgumentError, "invalid value for 'user_id' when calling SearchClient.remove_user_id, must conform to the pattern #{pattern}."
      end

      path = '/1/clusters/mapping/{userID}'.sub('{' + 'userID' + '}', @api_client.encode_uri(user_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.remove_user_id',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Remove userID.
    # Remove a userID and its associated data from the multi-clusters.
    # @param user_id [String] userID to assign. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RemoveUserIdResponse]
    def remove_user_id(user_id, request_options = {})
      response = remove_user_id_with_http_info(user_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::RemoveUserIdResponse')
    end

    # Replace all sources.
    # Replace all allowed sources.
    # @param source [Array<Source>] Allowed sources. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def replace_sources_with_http_info(source, request_options = {})
      # verify the required parameter 'source' is set
      if @api_client.config.client_side_validation && source.nil?
        raise ArgumentError, "Parameter `source` is required when calling `replace_sources`."
      end

      path = '/1/security/sources'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source)

      new_options = request_options.merge(
        :operation => :'SearchClient.replace_sources',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Replace all sources.
    # Replace all allowed sources.
    # @param source [Array<Source>] Allowed sources. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ReplaceSourceResponse]
    def replace_sources(source, request_options = {})
      response = replace_sources_with_http_info(source, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::ReplaceSourceResponse')
    end

    # Restore API key.
    # Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def restore_api_key_with_http_info(key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `restore_api_key`."
      end

      path = '/1/keys/{key}/restore'.sub('{' + 'key' + '}', @api_client.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :'SearchClient.restore_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Restore API key.
    # Restore a deleted API key, along with its associated permissions. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AddApiKeyResponse]
    def restore_api_key(key, request_options = {})
      response = restore_api_key_with_http_info(key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::AddApiKeyResponse')
    end

    # Add or update a record.
    # Add a record (object) to an index or replace it. If the record doesn&#39;t contain an &#x60;objectID&#x60;, Algolia automatically adds it. If you use an existing &#x60;objectID&#x60;, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [&#x60;batch&#x60; operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param body [Object] The Algolia record. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_object_with_http_info(index_name, body, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_object`."
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        raise ArgumentError, "Parameter `body` is required when calling `save_object`."
      end

      path = '/1/indexes/{indexName}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :'SearchClient.save_object',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Add or update a record.
    # Add a record (object) to an index or replace it. If the record doesn't contain an `objectID`, Algolia automatically adds it. If you use an existing `objectID`, the existing record is replaced with the new one. To add multiple records to your index in a single API request, use the [`batch` operation](#tag/Records/operation/batch).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param body [Object] The Algolia record. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SaveObjectResponse]
    def save_object(index_name, body, request_options = {})
      response = save_object_with_http_info(index_name, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SaveObjectResponse')
    end

    # Create or update a rule.
    # To create or update more than one rule, use the [&#x60;batch&#x60; operation](#tag/Rules/operation/saveRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param rule [Rule]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_rule_with_http_info(index_name, object_id, rule, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_rule`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `save_rule`."
      end
      # verify the required parameter 'rule' is set
      if @api_client.config.client_side_validation && rule.nil?
        raise ArgumentError, "Parameter `rule` is required when calling `save_rule`."
      end

      path = '/1/indexes/{indexName}/rules/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                 @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(rule)

      new_options = request_options.merge(
        :operation => :'SearchClient.save_rule',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Create or update a rule.
    # To create or update more than one rule, use the [`batch` operation](#tag/Rules/operation/saveRules).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a rule object. (required)
    # @param rule [Rule]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedRuleResponse]
    def save_rule(index_name, object_id, rule, forward_to_replicas = nil, request_options = {})
      response = save_rule_with_http_info(index_name, object_id, rule, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedRuleResponse')
    end

    # Save a batch of rules.
    # Create or update multiple rules.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param rules [Array<Rule>]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param clear_existing_rules [Boolean] Indicates whether existing rules should be deleted before adding this batch.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_rules_with_http_info(index_name, rules, forward_to_replicas = nil, clear_existing_rules = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_rules`."
      end
      # verify the required parameter 'rules' is set
      if @api_client.config.client_side_validation && rules.nil?
        raise ArgumentError, "Parameter `rules` is required when calling `save_rules`."
      end

      path = '/1/indexes/{indexName}/rules/batch'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params[:clearExistingRules] = clear_existing_rules unless clear_existing_rules.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(rules)

      new_options = request_options.merge(
        :operation => :'SearchClient.save_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Save a batch of rules.
    # Create or update multiple rules.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param rules [Array<Rule>]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param clear_existing_rules [Boolean] Indicates whether existing rules should be deleted before adding this batch.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def save_rules(index_name, rules, forward_to_replicas = nil, clear_existing_rules = nil, request_options = {})
      response = save_rules_with_http_info(index_name, rules, forward_to_replicas, clear_existing_rules, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Save a synonym.
    # Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym &#x60;objectID&#x60; doesn&#39;t exist, Algolia adds a new one. If you use an existing synonym &#x60;objectID&#x60;, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [&#x60;batch&#x60; operation](#tag/Synonyms/operation/saveSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param synonym_hit [SynonymHit]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_synonym_with_http_info(index_name, object_id, synonym_hit, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_synonym`."
      end
      # verify the required parameter 'object_id' is set
      if @api_client.config.client_side_validation && object_id.nil?
        raise ArgumentError, "Parameter `object_id` is required when calling `save_synonym`."
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Parameter `synonym_hit` is required when calling `save_synonym`."
      end

      path = '/1/indexes/{indexName}/synonyms/{objectID}'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'objectID' + '}',
                                                                                                                                    @api_client.encode_uri(object_id.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      new_options = request_options.merge(
        :operation => :'SearchClient.save_synonym',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Save a synonym.
    # Add a [synonym](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/adding-synonyms/#the-different-types-of-synonyms) to an index or replace it. If the synonym `objectID` doesn't exist, Algolia adds a new one. If you use an existing synonym `objectID`, the existing synonym is replaced with the new one. To add multiple synonyms in a single API request, use the [`batch` operation](#tag/Synonyms/operation/saveSynonyms).
    # @param index_name [String] Index on which to perform the request. (required)
    # @param object_id [String] Unique identifier of a synonym object. (required)
    # @param synonym_hit [SynonymHit]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SaveSynonymResponse]
    def save_synonym(index_name, object_id, synonym_hit, forward_to_replicas = nil, request_options = {})
      response = save_synonym_with_http_info(index_name, object_id, synonym_hit, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SaveSynonymResponse')
    end

    # Save a batch of synonyms.
    # Create or update multiple synonyms.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param synonym_hit [Array<SynonymHit>]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param replace_existing_synonyms [Boolean] Indicates whether to replace all synonyms in the index with the ones sent with this request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def save_synonyms_with_http_info(index_name, synonym_hit, forward_to_replicas = nil, replace_existing_synonyms = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `save_synonyms`."
      end
      # verify the required parameter 'synonym_hit' is set
      if @api_client.config.client_side_validation && synonym_hit.nil?
        raise ArgumentError, "Parameter `synonym_hit` is required when calling `save_synonyms`."
      end

      path = '/1/indexes/{indexName}/synonyms/batch'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params[:replaceExistingSynonyms] = replace_existing_synonyms unless replace_existing_synonyms.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(synonym_hit)

      new_options = request_options.merge(
        :operation => :'SearchClient.save_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Save a batch of synonyms.
    # Create or update multiple synonyms.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param synonym_hit [Array<SynonymHit>]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param replace_existing_synonyms [Boolean] Indicates whether to replace all synonyms in the index with the ones sent with this request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def save_synonyms(index_name, synonym_hit, forward_to_replicas = nil, replace_existing_synonyms = nil, request_options = {})
      response = save_synonyms_with_http_info(index_name, synonym_hit, forward_to_replicas, replace_existing_synonyms, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Search multiple indices.
    # Send multiple search queries to one or more indices.
    # @param search_method_params [SearchMethodParams] Query requests and strategies. Results will be received in the same order as the queries. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_with_http_info(search_method_params, request_options = {})
      # verify the required parameter 'search_method_params' is set
      if @api_client.config.client_side_validation && search_method_params.nil?
        raise ArgumentError, "Parameter `search_method_params` is required when calling `search`."
      end

      path = '/1/indexes/*/queries'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_method_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search multiple indices.
    # Send multiple search queries to one or more indices.
    # @param search_method_params [SearchMethodParams] Query requests and strategies. Results will be received in the same order as the queries. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchResponses]
    def search(search_method_params, request_options = {})
      response = search_with_http_info(search_method_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchResponses')
    end

    # Search dictionary entries.
    # Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
    # @param dictionary_name [DictionaryType] Dictionary to search in. (required)
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_dictionary_entries_with_http_info(dictionary_name, search_dictionary_entries_params, request_options = {})
      # verify the required parameter 'dictionary_name' is set
      if @api_client.config.client_side_validation && dictionary_name.nil?
        raise ArgumentError, "Parameter `dictionary_name` is required when calling `search_dictionary_entries`."
      end
      # verify the required parameter 'search_dictionary_entries_params' is set
      if @api_client.config.client_side_validation && search_dictionary_entries_params.nil?
        raise ArgumentError, "Parameter `search_dictionary_entries_params` is required when calling `search_dictionary_entries`."
      end

      path = '/1/dictionaries/{dictionaryName}/search'.sub('{' + 'dictionaryName' + '}', @api_client.encode_uri(dictionary_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_dictionary_entries_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_dictionary_entries',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search dictionary entries.
    # Search for standard and [custom](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/) entries in the [stop words](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-stop-words/), [plurals](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-plurals-and-other-declensions/), or [segmentation (compounds)](https://www.algolia.com/doc/guides/managing-results/optimize-search-results/handling-natural-languages-nlp/how-to/customize-segmentation/) dictionaries.
    # @param dictionary_name [DictionaryType] Dictionary to search in. (required)
    # @param search_dictionary_entries_params [SearchDictionaryEntriesParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def search_dictionary_entries(dictionary_name, search_dictionary_entries_params, request_options = {})
      response = search_dictionary_entries_with_http_info(dictionary_name, search_dictionary_entries_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Search for facet values.
    # [Search for a facet&#39;s values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. &gt; **Note**: Pagination isn&#39;t supported (&#x60;page&#x60; and &#x60;hitsPerPage&#x60; are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with &#x60;maxFacetHits&#x60;.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param facet_name [String] Facet name. (required)
    # @param search_for_facet_values_request [SearchForFacetValuesRequest]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_for_facet_values_with_http_info(index_name, facet_name, search_for_facet_values_request = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_for_facet_values`."
      end
      # verify the required parameter 'facet_name' is set
      if @api_client.config.client_side_validation && facet_name.nil?
        raise ArgumentError, "Parameter `facet_name` is required when calling `search_for_facet_values`."
      end

      path = '/1/indexes/{indexName}/facets/{facetName}/query'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s)).sub('{' + 'facetName' + '}',
                                                                                                                                         @api_client.encode_uri(facet_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_for_facet_values_request)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_for_facet_values',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for facet values.
    # [Search for a facet's values](https://www.algolia.com/doc/guides/managing-results/refine-results/faceting/#search-for-facet-values), optionally restricting the returned values to those contained in records matching other search criteria. > **Note**: Pagination isn't supported (`page` and `hitsPerPage` are ignored). By default, the engine returns a maximum of 10 values but you can adjust this with `maxFacetHits`.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param facet_name [String] Facet name. (required)
    # @param search_for_facet_values_request [SearchForFacetValuesRequest]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchForFacetValuesResponse]
    def search_for_facet_values(index_name, facet_name, search_for_facet_values_request = nil, request_options = {})
      response = search_for_facet_values_with_http_info(index_name, facet_name, search_for_facet_values_request, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchForFacetValuesResponse')
    end

    # Search for rules.
    # Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_rules_params [SearchRulesParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_rules_with_http_info(index_name, search_rules_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_rules`."
      end

      path = '/1/indexes/{indexName}/rules/search'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_rules_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_rules',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for rules.
    # Search for rules in your index. You can control the search with parameters. To list all rules, send an empty request body.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_rules_params [SearchRulesParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchRulesResponse]
    def search_rules(index_name, search_rules_params = nil, request_options = {})
      response = search_rules_with_http_info(index_name, search_rules_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchRulesResponse')
    end

    # Search an index.
    # Return records that match the query.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_params [SearchParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_single_index_with_http_info(index_name, search_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_single_index`."
      end

      path = '/1/indexes/{indexName}/query'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_single_index',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search an index.
    # Return records that match the query.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_params [SearchParams]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchResponse]
    def search_single_index(index_name, search_params = nil, request_options = {})
      response = search_single_index_with_http_info(index_name, search_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchResponse')
    end

    # Search for synonyms.
    # Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_synonyms_params [SearchSynonymsParams] Body of the &#x60;searchSynonyms&#x60; operation.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_synonyms_with_http_info(index_name, search_synonyms_params = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `search_synonyms`."
      end

      path = '/1/indexes/{indexName}/synonyms/search'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_synonyms_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_synonyms',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for synonyms.
    # Search for synonyms in your index. You can control and filter the search with parameters. To get all synonyms, send an empty request body.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param search_synonyms_params [SearchSynonymsParams] Body of the &#x60;searchSynonyms&#x60; operation.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchSynonymsResponse]
    def search_synonyms(index_name, search_synonyms_params = nil, request_options = {})
      response = search_synonyms_with_http_info(index_name, search_synonyms_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchSynonymsResponse')
    end

    # Search for a user ID.
    # Since it can take up to a few seconds to get the data from the different clusters, the response isn&#39;t real-time. To ensure rapid updates, the user IDs index isn&#39;t built at the same time as the mapping. Instead, it&#39;s built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    # @param search_user_ids_params [SearchUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_user_ids_with_http_info(search_user_ids_params, request_options = {})
      # verify the required parameter 'search_user_ids_params' is set
      if @api_client.config.client_side_validation && search_user_ids_params.nil?
        raise ArgumentError, "Parameter `search_user_ids_params` is required when calling `search_user_ids`."
      end

      path = '/1/clusters/mapping/search'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(search_user_ids_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.search_user_ids',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => true
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search for a user ID.
    # Since it can take up to a few seconds to get the data from the different clusters, the response isn't real-time. To ensure rapid updates, the user IDs index isn't built at the same time as the mapping. Instead, it's built every 12 hours, at the same time as the update of user ID usage. For example, if you add or move a user ID, the search will show an old value until the next time the mapping is rebuilt (every 12 hours).
    # @param search_user_ids_params [SearchUserIdsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SearchUserIdsResponse]
    def search_user_ids(search_user_ids_params, request_options = {})
      response = search_user_ids_with_http_info(search_user_ids_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::SearchUserIdsResponse')
    end

    # Set stop word settings.
    # Set stop word settings for a specific language.
    # @param dictionary_settings_params [DictionarySettingsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def set_dictionary_settings_with_http_info(dictionary_settings_params, request_options = {})
      # verify the required parameter 'dictionary_settings_params' is set
      if @api_client.config.client_side_validation && dictionary_settings_params.nil?
        raise ArgumentError, "Parameter `dictionary_settings_params` is required when calling `set_dictionary_settings`."
      end

      path = '/1/dictionaries/*/settings'
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(dictionary_settings_params)

      new_options = request_options.merge(
        :operation => :'SearchClient.set_dictionary_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Set stop word settings.
    # Set stop word settings for a specific language.
    # @param dictionary_settings_params [DictionarySettingsParams]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def set_dictionary_settings(dictionary_settings_params, request_options = {})
      response = set_dictionary_settings_with_http_info(dictionary_settings_params, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Update index settings.
    # Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param index_settings [IndexSettings]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def set_settings_with_http_info(index_name, index_settings, forward_to_replicas = nil, request_options = {})
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `set_settings`."
      end
      # verify the required parameter 'index_settings' is set
      if @api_client.config.client_side_validation && index_settings.nil?
        raise ArgumentError, "Parameter `index_settings` is required when calling `set_settings`."
      end

      path = '/1/indexes/{indexName}/settings'.sub('{' + 'indexName' + '}', @api_client.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:forwardToReplicas] = forward_to_replicas unless forward_to_replicas.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(index_settings)

      new_options = request_options.merge(
        :operation => :'SearchClient.set_settings',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Update index settings.
    # Update the specified [index settings](https://www.algolia.com/doc/api-reference/settings-api-parameters/). Specifying null for a setting resets it to its default value.
    # @param index_name [String] Index on which to perform the request. (required)
    # @param index_settings [IndexSettings]  (required)
    # @param forward_to_replicas [Boolean] Indicates whether changed index settings are forwarded to the replica indices.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdatedAtResponse]
    def set_settings(index_name, index_settings, forward_to_replicas = nil, request_options = {})
      response = set_settings_with_http_info(index_name, index_settings, forward_to_replicas, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdatedAtResponse')
    end

    # Update an API key.
    # Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_api_key_with_http_info(key, api_key, request_options = {})
      # verify the required parameter 'key' is set
      if @api_client.config.client_side_validation && key.nil?
        raise ArgumentError, "Parameter `key` is required when calling `update_api_key`."
      end
      # verify the required parameter 'api_key' is set
      if @api_client.config.client_side_validation && api_key.nil?
        raise ArgumentError, "Parameter `api_key` is required when calling `update_api_key`."
      end

      path = '/1/keys/{key}'.sub('{' + 'key' + '}', @api_client.encode_uri(key.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(api_key)

      new_options = request_options.merge(
        :operation => :'SearchClient.update_api_key',
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Update an API key.
    # Replace the permissions of an existing API key. Any unspecified parameter resets that permission to its default value. The request must be authenticated with the admin API key.
    # @param key [String] API key. (required)
    # @param api_key [ApiKey]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [UpdateApiKeyResponse]
    def update_api_key(key, api_key, request_options = {})
      response = update_api_key_with_http_info(key, api_key, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || 'Search::UpdateApiKeyResponse')
    end

    # Helper: Wait for a task to be published (completed) for a given `index_name` and `task_id`.
    #
    # @param index_name [String] the `index_name` where the operation was performed. (required)
    # @param task_id [Integer] the `task_id` returned in the method response. (required)
    # @param max_retries [Integer] the maximum number of retries. (optional, default to 50)
    # @param timeout [Proc] the function to decide how long to wait between retries. (optional)
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `get_task` method.
    # @return [Http::Response] the last get_task response
    def wait_for_task(index_name, task_id, max_retries = 50, timeout = ->(retry_count) { [retry_count * 200, 5000].min }, request_options = {})
      retries = 0
      while retries < max_retries
        res = get_task(index_name, task_id, request_options)
        if res.status == 'published'
          return res
        end

        retries += 1
        sleep(timeout.call(retries) / 1000.0)
      end
      raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
    end

    # Helper: Wait for an API key to be added, updated or deleted based on a given `operation`.
    #
    # @param operation [String] the `operation` that was done on a `key`.
    # @param key [String] the `key` that has been added, deleted or updated.
    # @param api_key [Hash] necessary to know if an `update` operation has been processed, compare fields of the response with it.
    # @param max_retries [Integer] the maximum number of retries.
    # @param timeout [Proc] the function to decide how long to wait between retries.
    # @param request_options [Hash] the requestOptions to send along with the query, they will be forwarded to the `getApikey` method and merged with the transporter requestOptions.
    # @return [Http::Response] the last get_api_key response
    def wait_for_api_key(operation, key, api_key = {}, max_retries = 50, timeout = ->(retry_count) { [retry_count * 200, 5000].min }, request_options = {})
      retries = 0
      if operation == 'update'
        raise ArgumentError, '`api_key` is required when waiting for an `update` operation.' if api_key.nil?

        while retries < max_retries
          begin
            updatad_key = get_api_key(key, request_options)
            updated_key_hash = updatad_key.to_hash
            equals = true
            api_key.to_hash.each do |k, v|
              equals &&= updated_key_hash[k] == v
            end

            return updatad_key if equals
          rescue AlgoliaError => e
            raise e unless e.code == 404
          end

          retries += 1
          sleep(timeout.call(retries) / 1000.0)
        end

        raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
      end

      while retries < max_retries
        begin
          res = get_api_key(key, request_options)
          return res if operation == 'add'
        rescue AlgoliaError => e
          return res if operation == 'delete' && e.code == 404
        end
        retries += 1
        sleep(timeout.call(retries) / 1000.0)
      end
      raise ApiError, "The maximum number of retries exceeded. (#{max_retries})"
    end
  end
end
