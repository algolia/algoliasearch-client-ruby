# frozen_string_literal: true

# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

module Algolia
  class IngestionClient
    attr_accessor :api_client

    def initialize(config = nil)
      raise "`config` is missing." if config.nil?
      raise "`app_id` is missing." if config.app_id.nil? || config.app_id == ""
      raise "`api_key` is missing." if config.api_key.nil? || config.api_key == ""

      @api_client = Algolia::ApiClient.new(config)
    end

    def self.create(app_id, api_key, region = nil, opts = {})
      hosts = []
      regions = ["eu", "us"]

      if region.is_a?(Hash) && (opts.nil? || opts.empty?)
        opts = region
        region = nil
      end

      if region.nil? || !region.is_a?(String) || !regions.include?(region)
        raise "`region` is required and must be one of the following: #{regions.join(", ")}"
      end

      hosts <<
        Transport::StatefulHost.new(
          "data.{region}.algolia.com".sub("{region}", region),
          accept: CallType::READ | CallType::WRITE
        )

      config = Algolia::Configuration.new(app_id, api_key, hosts, "Ingestion", opts)
      create_with_config(config)
    end

    def self.create_with_config(config)
      if config.connect_timeout.nil?
        config.connect_timeout = 25000
      end

      if config.read_timeout.nil?
        config.read_timeout = 25000
      end

      if config.write_timeout.nil?
        config.write_timeout = 25000
      end

      new(config)
    end

    # Helper method to switch the API key used to authenticate the requests.
    #
    # @param api_key [String] the new API key to use.
    # @return [void]
    def set_client_api_key(api_key)
      @api_client.set_client_api_key(api_key)

      self
    end

    def add_user_agent_segment(segment, version = nil)
      @api_client.config.add_user_agent_segment(segment, version)

      self
    end

    # Creates a new authentication resource.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_create [AuthenticationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_authentication_with_http_info(authentication_create, request_options = {})
      # verify the required parameter 'authentication_create' is set
      if @api_client.config.client_side_validation && authentication_create.nil?
        raise ArgumentError, "Parameter `authentication_create` is required when calling `create_authentication`."
      end

      path = "/1/authentications"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(authentication_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new authentication resource.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_create [AuthenticationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AuthenticationCreateResponse]
    def create_authentication(authentication_create, request_options = {})
      response = create_authentication_with_http_info(authentication_create, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::AuthenticationCreateResponse"
      )
    end

    # Creates a new destination.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_create [DestinationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_destination_with_http_info(destination_create, request_options = {})
      # verify the required parameter 'destination_create' is set
      if @api_client.config.client_side_validation && destination_create.nil?
        raise ArgumentError, "Parameter `destination_create` is required when calling `create_destination`."
      end

      path = "/1/destinations"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(destination_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new destination.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_create [DestinationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DestinationCreateResponse]
    def create_destination(destination_create, request_options = {})
      response = create_destination_with_http_info(destination_create, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::DestinationCreateResponse"
      )
    end

    # Creates a new source.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_create [SourceCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_source_with_http_info(source_create, request_options = {})
      # verify the required parameter 'source_create' is set
      if @api_client.config.client_side_validation && source_create.nil?
        raise ArgumentError, "Parameter `source_create` is required when calling `create_source`."
      end

      path = "/1/sources"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new source.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_create [SourceCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SourceCreateResponse]
    def create_source(source_create, request_options = {})
      response = create_source_with_http_info(source_create, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::SourceCreateResponse")
    end

    # Creates a new task.

    # @param task_create [TaskCreate] Request body for creating a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_task_with_http_info(task_create, request_options = {})
      # verify the required parameter 'task_create' is set
      if @api_client.config.client_side_validation && task_create.nil?
        raise ArgumentError, "Parameter `task_create` is required when calling `create_task`."
      end

      path = "/2/tasks"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new task.

    # @param task_create [TaskCreate] Request body for creating a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskCreateResponse]
    def create_task(task_create, request_options = {})
      response = create_task_with_http_info(task_create, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskCreateResponse")
    end

    # Creates a new task using the v1 endpoint, please use `createTask` instead.

    # THIS OPERATION IS DEPRECATED
    # @param task_create [TaskCreateV1] Request body for creating a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_task_v1_with_http_info(task_create, request_options = {})
      # verify the required parameter 'task_create' is set
      if @api_client.config.client_side_validation && task_create.nil?
        raise ArgumentError, "Parameter `task_create` is required when calling `create_task_v1`."
      end

      path = "/1/tasks"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new task using the v1 endpoint, please use `createTask` instead.

    # @param task_create [TaskCreateV1] Request body for creating a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskCreateResponse]
    def create_task_v1(task_create, request_options = {})
      response = create_task_v1_with_http_info(task_create, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskCreateResponse")
    end

    # Creates a new transformation.

    # @param transformation_create [TransformationCreate] Request body for creating a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def create_transformation_with_http_info(transformation_create, request_options = {})
      # verify the required parameter 'transformation_create' is set
      if @api_client.config.client_side_validation && transformation_create.nil?
        raise ArgumentError, "Parameter `transformation_create` is required when calling `create_transformation`."
      end

      path = "/1/transformations"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(transformation_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.create_transformation",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Creates a new transformation.

    # @param transformation_create [TransformationCreate] Request body for creating a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TransformationCreateResponse]
    def create_transformation(transformation_create, request_options = {})
      response = create_transformation_with_http_info(transformation_create, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::TransformationCreateResponse"
      )
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_delete_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_delete`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.custom_delete",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_delete(path, parameters = nil, request_options = {})
      response = custom_delete_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_get_with_http_info(path, parameters = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_get`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.custom_get",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_get(path, parameters = nil, request_options = {})
      response = custom_get_with_http_info(path, parameters, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_post_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_post`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"IngestionClient.custom_post",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_post(path, parameters = nil, body = nil, request_options = {})
      response = custom_post_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def custom_put_with_http_info(path, parameters = nil, body = nil, request_options = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        raise ArgumentError, "Parameter `path` is required when calling `custom_put`."
      end

      path = "/{path}".sub("{" + "path" + "}", path.to_s)
      query_params = {}
      query_params = query_params.merge(parameters) unless parameters.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(body)

      new_options = request_options.merge(
        :operation => :"IngestionClient.custom_put",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # This method lets you send requests to the Algolia REST API.

    # @param path [String] Path of the endpoint, for example `1/newFeature`. (required)
    # @param parameters [Hash<String, Object>] Query parameters to apply to the current query.
    # @param body [Object] Parameters to send with the custom request.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Object]
    def custom_put(path, parameters = nil, body = nil, request_options = {})
      response = custom_put_with_http_info(path, parameters, body, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Object")
    end

    # Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_authentication_with_http_info(authentication_id, request_options = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        raise ArgumentError, "Parameter `authentication_id` is required when calling `delete_authentication`."
      end

      path = "/1/authentications/{authenticationID}".sub(
        "{" + "authenticationID" + "}",
        Transport.encode_uri(authentication_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes an authentication resource. You can't delete authentication resources that are used by a source or a destination.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_authentication(authentication_id, request_options = {})
      response = delete_authentication_with_http_info(authentication_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_destination_with_http_info(destination_id, request_options = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        raise ArgumentError, "Parameter `destination_id` is required when calling `delete_destination`."
      end

      path = "/1/destinations/{destinationID}".sub(
        "{" + "destinationID" + "}",
        Transport.encode_uri(destination_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a destination by its ID. You can't delete destinations that are referenced in tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_destination(destination_id, request_options = {})
      response = delete_destination_with_http_info(destination_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Deletes a source by its ID. You can't delete sources that are referenced in tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_source_with_http_info(source_id, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `delete_source`."
      end

      path = "/1/sources/{sourceID}".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a source by its ID. You can't delete sources that are referenced in tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_source(source_id, request_options = {})
      response = delete_source_with_http_info(source_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Deletes a task by its ID.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_task_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `delete_task`."
      end

      path = "/2/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a task by its ID.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_task(task_id, request_options = {})
      response = delete_task_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_task_v1_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `delete_task_v1`."
      end

      path = "/1/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a task by its ID using the v1 endpoint, please use `deleteTask` instead.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_task_v1(task_id, request_options = {})
      response = delete_task_v1_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Deletes a transformation by its ID.

    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def delete_transformation_with_http_info(transformation_id, request_options = {})
      # verify the required parameter 'transformation_id' is set
      if @api_client.config.client_side_validation && transformation_id.nil?
        raise ArgumentError, "Parameter `transformation_id` is required when calling `delete_transformation`."
      end

      path = "/1/transformations/{transformationID}".sub(
        "{" + "transformationID" + "}",
        Transport.encode_uri(transformation_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.delete_transformation",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Deletes a transformation by its ID.

    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DeleteResponse]
    def delete_transformation(transformation_id, request_options = {})
      response = delete_transformation_with_http_info(transformation_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::DeleteResponse")
    end

    # Disables a task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def disable_task_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `disable_task`."
      end

      path = "/2/tasks/{taskID}/disable".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.disable_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Disables a task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def disable_task(task_id, request_options = {})
      response = disable_task_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Disables a task using the v1 endpoint, please use `disableTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def disable_task_v1_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `disable_task_v1`."
      end

      path = "/1/tasks/{taskID}/disable".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.disable_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Disables a task using the v1 endpoint, please use `disableTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def disable_task_v1(task_id, request_options = {})
      response = disable_task_v1_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Enables a task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def enable_task_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `enable_task`."
      end

      path = "/2/tasks/{taskID}/enable".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.enable_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Enables a task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def enable_task(task_id, request_options = {})
      response = enable_task_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Enables a task using the v1 endpoint, please use `enableTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def enable_task_v1_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `enable_task_v1`."
      end

      path = "/1/tasks/{taskID}/enable".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.enable_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Enables a task using the v1 endpoint, please use `enableTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def enable_task_v1(task_id, request_options = {})
      response = enable_task_v1_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Retrieves an authentication resource by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_authentication_with_http_info(authentication_id, request_options = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        raise ArgumentError, "Parameter `authentication_id` is required when calling `get_authentication`."
      end

      path = "/1/authentications/{authenticationID}".sub(
        "{" + "authenticationID" + "}",
        Transport.encode_uri(authentication_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves an authentication resource by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Authentication]
    def get_authentication(authentication_id, request_options = {})
      response = get_authentication_with_http_info(authentication_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Authentication")
    end

    # Retrieves a destination by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_destination_with_http_info(destination_id, request_options = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        raise ArgumentError, "Parameter `destination_id` is required when calling `get_destination`."
      end

      path = "/1/destinations/{destinationID}".sub(
        "{" + "destinationID" + "}",
        Transport.encode_uri(destination_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a destination by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Destination]
    def get_destination(destination_id, request_options = {})
      response = get_destination_with_http_info(destination_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Destination")
    end

    # Retrieves a single task run event by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param event_id [String] Unique identifier of an event. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_event_with_http_info(run_id, event_id, request_options = {})
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        raise ArgumentError, "Parameter `run_id` is required when calling `get_event`."
      end
      # verify the required parameter 'event_id' is set
      if @api_client.config.client_side_validation && event_id.nil?
        raise ArgumentError, "Parameter `event_id` is required when calling `get_event`."
      end

      path = "/1/runs/{runID}/events/{eventID}".sub("{" + "runID" + "}", Transport.encode_uri(run_id.to_s)).sub(
        "{" + "eventID" + "}",
        Transport.encode_uri(event_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_event",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a single task run event by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param event_id [String] Unique identifier of an event. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Event]
    def get_event(run_id, event_id, request_options = {})
      response = get_event_with_http_info(run_id, event_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Event")
    end

    # Retrieve a single task run by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_run_with_http_info(run_id, request_options = {})
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        raise ArgumentError, "Parameter `run_id` is required when calling `get_run`."
      end

      path = "/1/runs/{runID}".sub("{" + "runID" + "}", Transport.encode_uri(run_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_run",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieve a single task run by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Run]
    def get_run(run_id, request_options = {})
      response = get_run_with_http_info(run_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Run")
    end

    # Retrieve a source by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_source_with_http_info(source_id, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `get_source`."
      end

      path = "/1/sources/{sourceID}".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieve a source by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Source]
    def get_source(source_id, request_options = {})
      response = get_source_with_http_info(source_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Source")
    end

    # Retrieves a task by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_task_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `get_task`."
      end

      path = "/2/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a task by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Task]
    def get_task(task_id, request_options = {})
      response = get_task_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Task")
    end

    # Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_task_v1_with_http_info(task_id, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `get_task_v1`."
      end

      path = "/1/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a task by its ID using the v1 endpoint, please use `getTask` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskV1]
    def get_task_v1(task_id, request_options = {})
      response = get_task_v1_with_http_info(task_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskV1")
    end

    # Retrieves a transformation by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def get_transformation_with_http_info(transformation_id, request_options = {})
      # verify the required parameter 'transformation_id' is set
      if @api_client.config.client_side_validation && transformation_id.nil?
        raise ArgumentError, "Parameter `transformation_id` is required when calling `get_transformation`."
      end

      path = "/1/transformations/{transformationID}".sub(
        "{" + "transformationID" + "}",
        Transport.encode_uri(transformation_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.get_transformation",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a transformation by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Transformation]
    def get_transformation(transformation_id, request_options = {})
      response = get_transformation_with_http_info(transformation_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::Transformation")
    end

    # Retrieves a list of all authentication resources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<AuthenticationType>] Type of authentication resource to retrieve.
    # @param platform [Array<PlatformWithNone>] Ecommerce platform for which to retrieve authentications.
    # @param sort [AuthenticationSortKeys] Property by which to sort the list of authentications. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_authentications_with_http_info(
      items_per_page = nil,
      page = nil,
      type = nil,
      platform = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/1/authentications"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:type] = @api_client.build_collection_param(type, :csv) unless type.nil?
      query_params[:platform] = @api_client.build_collection_param(platform, :csv) unless platform.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_authentications",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of all authentication resources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<AuthenticationType>] Type of authentication resource to retrieve.
    # @param platform [Array<PlatformWithNone>] Ecommerce platform for which to retrieve authentications.
    # @param sort [AuthenticationSortKeys] Property by which to sort the list of authentications. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListAuthenticationsResponse]
    def list_authentications(
      items_per_page = nil,
      page = nil,
      type = nil,
      platform = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      response = list_authentications_with_http_info(items_per_page, page, type, platform, sort, order, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::ListAuthenticationsResponse"
      )
    end

    # Retrieves a list of destinations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<DestinationType>] Destination type.
    # @param authentication_id [Array<String>] Authentication ID used by destinations.
    # @param transformation_id [String] Get the list of destinations used by a transformation.
    # @param sort [DestinationSortKeys] Property by which to sort the destinations. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_destinations_with_http_info(
      items_per_page = nil,
      page = nil,
      type = nil,
      authentication_id = nil,
      transformation_id = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/1/destinations"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:type] = @api_client.build_collection_param(type, :csv) unless type.nil?
      unless authentication_id.nil?
        query_params[:authenticationID] = @api_client.build_collection_param(authentication_id, :csv)
      end

      query_params[:transformationID] = transformation_id unless transformation_id.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_destinations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of destinations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<DestinationType>] Destination type.
    # @param authentication_id [Array<String>] Authentication ID used by destinations.
    # @param transformation_id [String] Get the list of destinations used by a transformation.
    # @param sort [DestinationSortKeys] Property by which to sort the destinations. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListDestinationsResponse]
    def list_destinations(
      items_per_page = nil,
      page = nil,
      type = nil,
      authentication_id = nil,
      transformation_id = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      response = list_destinations_with_http_info(
        items_per_page,
        page,
        type,
        authentication_id,
        transformation_id,
        sort,
        order,
        request_options
      )
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::ListDestinationsResponse"
      )
    end

    # Retrieves a list of events for a task run, identified by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param status [Array<EventStatus>] Event status for filtering the list of task runs.
    # @param type [Array<EventType>] Event type for filtering the list of task runs.
    # @param sort [EventSortKeys] Property by which to sort the list of task run events.
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param start_date [String] Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
    # @param end_date [String] Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_events_with_http_info(
      run_id,
      items_per_page = nil,
      page = nil,
      status = nil,
      type = nil,
      sort = nil,
      order = nil,
      start_date = nil,
      end_date = nil,
      request_options = {}
    )
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        raise ArgumentError, "Parameter `run_id` is required when calling `list_events`."
      end

      path = "/1/runs/{runID}/events".sub("{" + "runID" + "}", Transport.encode_uri(run_id.to_s))
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:status] = @api_client.build_collection_param(status, :multi) unless status.nil?
      query_params[:type] = @api_client.build_collection_param(type, :multi) unless type.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params[:startDate] = start_date unless start_date.nil?
      query_params[:endDate] = end_date unless end_date.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_events",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of events for a task run, identified by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param run_id [String] Unique identifier of a task run. (required)
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param status [Array<EventStatus>] Event status for filtering the list of task runs.
    # @param type [Array<EventType>] Event type for filtering the list of task runs.
    # @param sort [EventSortKeys] Property by which to sort the list of task run events.
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param start_date [String] Date and time in RFC 3339 format for the earliest events to retrieve. By default, the current time minus three hours is used.
    # @param end_date [String] Date and time in RFC 3339 format for the latest events to retrieve. By default, the current time is used.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListEventsResponse]
    def list_events(
      run_id,
      items_per_page = nil,
      page = nil,
      status = nil,
      type = nil,
      sort = nil,
      order = nil,
      start_date = nil,
      end_date = nil,
      request_options = {}
    )
      response = list_events_with_http_info(
        run_id,
        items_per_page,
        page,
        status,
        type,
        sort,
        order,
        start_date,
        end_date,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::ListEventsResponse")
    end

    # Retrieve a list of task runs.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param status [Array<RunStatus>] Run status for filtering the list of task runs.
    # @param type [Array<RunType>] Run type for filtering the list of task runs.
    # @param task_id [String] Task ID for filtering the list of task runs.
    # @param sort [RunSortKeys] Property by which to sort the list of task runs. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param start_date [String] Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
    # @param end_date [String] Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_runs_with_http_info(
      items_per_page = nil,
      page = nil,
      status = nil,
      type = nil,
      task_id = nil,
      sort = nil,
      order = nil,
      start_date = nil,
      end_date = nil,
      request_options = {}
    )
      path = "/1/runs"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:status] = @api_client.build_collection_param(status, :multi) unless status.nil?
      query_params[:type] = @api_client.build_collection_param(type, :multi) unless type.nil?
      query_params[:taskID] = task_id unless task_id.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params[:startDate] = start_date unless start_date.nil?
      query_params[:endDate] = end_date unless end_date.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_runs",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieve a list of task runs.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param status [Array<RunStatus>] Run status for filtering the list of task runs.
    # @param type [Array<RunType>] Run type for filtering the list of task runs.
    # @param task_id [String] Task ID for filtering the list of task runs.
    # @param sort [RunSortKeys] Property by which to sort the list of task runs. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param start_date [String] Date in RFC 3339 format for the earliest run to retrieve. By default, the current day minus seven days is used.
    # @param end_date [String] Date in RFC 3339 format for the latest run to retrieve. By default, the current day is used.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RunListResponse]
    def list_runs(
      items_per_page = nil,
      page = nil,
      status = nil,
      type = nil,
      task_id = nil,
      sort = nil,
      order = nil,
      start_date = nil,
      end_date = nil,
      request_options = {}
    )
      response = list_runs_with_http_info(
        items_per_page,
        page,
        status,
        type,
        task_id,
        sort,
        order,
        start_date,
        end_date,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::RunListResponse")
    end

    # Retrieves a list of sources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<SourceType>] Source type. Some sources require authentication.
    # @param authentication_id [Array<String>] Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
    # @param sort [SourceSortKeys] Property by which to sort the list of sources. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_sources_with_http_info(
      items_per_page = nil,
      page = nil,
      type = nil,
      authentication_id = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/1/sources"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:type] = @api_client.build_collection_param(type, :csv) unless type.nil?
      unless authentication_id.nil?
        query_params[:authenticationID] = @api_client.build_collection_param(authentication_id, :csv)
      end

      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of sources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param type [Array<SourceType>] Source type. Some sources require authentication.
    # @param authentication_id [Array<String>] Authentication IDs of the sources to retrieve. 'none' returns sources that doesn't have an authentication.
    # @param sort [SourceSortKeys] Property by which to sort the list of sources. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListSourcesResponse]
    def list_sources(
      items_per_page = nil,
      page = nil,
      type = nil,
      authentication_id = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      response = list_sources_with_http_info(
        items_per_page,
        page,
        type,
        authentication_id,
        sort,
        order,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::ListSourcesResponse")
    end

    # Retrieves a list of tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param action [Array<ActionType>] Actions for filtering the list of tasks.
    # @param enabled [Boolean] Whether to filter the list of tasks by the `enabled` status.
    # @param source_id [Array<String>] Source IDs for filtering the list of tasks.
    # @param source_type [Array<SourceType>] Filters the tasks with the specified source type.
    # @param destination_id [Array<String>] Destination IDs for filtering the list of tasks.
    # @param trigger_type [Array<TriggerType>] Type of task trigger for filtering the list of tasks.
    # @param with_email_notifications [Boolean] If specified, the response only includes tasks with notifications.email.enabled set to this value.
    # @param sort [TaskSortKeys] Property by which to sort the list of tasks. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_tasks_with_http_info(
      items_per_page = nil,
      page = nil,
      action = nil,
      enabled = nil,
      source_id = nil,
      source_type = nil,
      destination_id = nil,
      trigger_type = nil,
      with_email_notifications = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/2/tasks"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:action] = @api_client.build_collection_param(action, :csv) unless action.nil?
      query_params[:enabled] = enabled unless enabled.nil?
      query_params[:sourceID] = @api_client.build_collection_param(source_id, :csv) unless source_id.nil?
      query_params[:sourceType] = @api_client.build_collection_param(source_type, :csv) unless source_type.nil?
      unless destination_id.nil?
        query_params[:destinationID] = @api_client.build_collection_param(destination_id, :csv)
      end

      query_params[:triggerType] = @api_client.build_collection_param(trigger_type, :csv) unless trigger_type.nil?
      query_params[:withEmailNotifications] = with_email_notifications unless with_email_notifications.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_tasks",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param action [Array<ActionType>] Actions for filtering the list of tasks.
    # @param enabled [Boolean] Whether to filter the list of tasks by the `enabled` status.
    # @param source_id [Array<String>] Source IDs for filtering the list of tasks.
    # @param source_type [Array<SourceType>] Filters the tasks with the specified source type.
    # @param destination_id [Array<String>] Destination IDs for filtering the list of tasks.
    # @param trigger_type [Array<TriggerType>] Type of task trigger for filtering the list of tasks.
    # @param with_email_notifications [Boolean] If specified, the response only includes tasks with notifications.email.enabled set to this value.
    # @param sort [TaskSortKeys] Property by which to sort the list of tasks. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListTasksResponse]
    def list_tasks(
      items_per_page = nil,
      page = nil,
      action = nil,
      enabled = nil,
      source_id = nil,
      source_type = nil,
      destination_id = nil,
      trigger_type = nil,
      with_email_notifications = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      response = list_tasks_with_http_info(
        items_per_page,
        page,
        action,
        enabled,
        source_id,
        source_type,
        destination_id,
        trigger_type,
        with_email_notifications,
        sort,
        order,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::ListTasksResponse")
    end

    # Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param action [Array<ActionType>] Actions for filtering the list of tasks.
    # @param enabled [Boolean] Whether to filter the list of tasks by the `enabled` status.
    # @param source_id [Array<String>] Source IDs for filtering the list of tasks.
    # @param destination_id [Array<String>] Destination IDs for filtering the list of tasks.
    # @param trigger_type [Array<TriggerType>] Type of task trigger for filtering the list of tasks.
    # @param sort [TaskSortKeys] Property by which to sort the list of tasks. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_tasks_v1_with_http_info(
      items_per_page = nil,
      page = nil,
      action = nil,
      enabled = nil,
      source_id = nil,
      destination_id = nil,
      trigger_type = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/1/tasks"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:action] = @api_client.build_collection_param(action, :csv) unless action.nil?
      query_params[:enabled] = enabled unless enabled.nil?
      query_params[:sourceID] = @api_client.build_collection_param(source_id, :csv) unless source_id.nil?
      unless destination_id.nil?
        query_params[:destinationID] = @api_client.build_collection_param(destination_id, :csv)
      end

      query_params[:triggerType] = @api_client.build_collection_param(trigger_type, :csv) unless trigger_type.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_tasks_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of tasks using the v1 endpoint, please use `getTasks` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param action [Array<ActionType>] Actions for filtering the list of tasks.
    # @param enabled [Boolean] Whether to filter the list of tasks by the `enabled` status.
    # @param source_id [Array<String>] Source IDs for filtering the list of tasks.
    # @param destination_id [Array<String>] Destination IDs for filtering the list of tasks.
    # @param trigger_type [Array<TriggerType>] Type of task trigger for filtering the list of tasks.
    # @param sort [TaskSortKeys] Property by which to sort the list of tasks. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListTasksResponseV1]
    def list_tasks_v1(
      items_per_page = nil,
      page = nil,
      action = nil,
      enabled = nil,
      source_id = nil,
      destination_id = nil,
      trigger_type = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      response = list_tasks_v1_with_http_info(
        items_per_page,
        page,
        action,
        enabled,
        source_id,
        destination_id,
        trigger_type,
        sort,
        order,
        request_options
      )
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::ListTasksResponseV1")
    end

    # Retrieves a list of transformations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param sort [TransformationSortKeys] Property by which to sort the list of transformations. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def list_transformations_with_http_info(
      items_per_page = nil,
      page = nil,
      sort = nil,
      order = nil,
      request_options = {}
    )
      path = "/1/transformations"
      query_params = {}
      query_params[:itemsPerPage] = items_per_page unless items_per_page.nil?
      query_params[:page] = page unless page.nil?
      query_params[:sort] = sort unless sort.nil?
      query_params[:order] = order unless order.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.list_transformations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieves a list of transformations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param items_per_page [Integer] Number of items per page. (default to 10)
    # @param page [Integer] Page number of the paginated API response.
    # @param sort [TransformationSortKeys] Property by which to sort the list of transformations. (default to 'createdAt')
    # @param order [OrderKeys] Sort order of the response, ascending or descending. (default to 'desc')
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [ListTransformationsResponse]
    def list_transformations(items_per_page = nil, page = nil, sort = nil, order = nil, request_options = {})
      response = list_transformations_with_http_info(items_per_page, page, sort, order, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::ListTransformationsResponse"
      )
    end

    # Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/), this is the recommended way of ingesting your records. This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param push_task_payload [PushTaskPayload]  (required)
    # @param watch [Boolean] When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
    # @param reference_index_name [String] This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def push_with_http_info(
      index_name,
      push_task_payload,
      watch = nil,
      reference_index_name = nil,
      request_options = {}
    )
      # verify the required parameter 'index_name' is set
      if @api_client.config.client_side_validation && index_name.nil?
        raise ArgumentError, "Parameter `index_name` is required when calling `push`."
      end
      # verify the required parameter 'push_task_payload' is set
      if @api_client.config.client_side_validation && push_task_payload.nil?
        raise ArgumentError, "Parameter `push_task_payload` is required when calling `push`."
      end

      path = "/1/push/{indexName}".sub("{" + "indexName" + "}", Transport.encode_uri(index_name.to_s))
      query_params = {}
      query_params[:watch] = watch unless watch.nil?
      query_params[:referenceIndexName] = reference_index_name unless reference_index_name.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?
      request_options[:timeout] ||= 180000
      request_options[:connect_timeout] ||= 180000

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(push_task_payload)

      new_options = request_options.merge(
        :operation => :"IngestionClient.push",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/), this is the recommended way of ingesting your records. This method is similar to `pushTask`, but requires an `indexName` instead of a `taskID`. If zero or many tasks are found, an error will be returned.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param index_name [String] Name of the index on which to perform the operation. (required)
    # @param push_task_payload [PushTaskPayload]  (required)
    # @param watch [Boolean] When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
    # @param reference_index_name [String] This is required when targeting an index that does not have a push connector setup (e.g. a tmp index), but you wish to attach another index's transformation to it (e.g. the source index name).
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [WatchResponse]
    def push(index_name, push_task_payload, watch = nil, reference_index_name = nil, request_options = {})
      response = push_with_http_info(index_name, push_task_payload, watch, reference_index_name, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::WatchResponse")
    end

    # Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/), this is the recommended way of ingesting your records. This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param push_task_payload [PushTaskPayload]  (required)
    # @param watch [Boolean] When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def push_task_with_http_info(task_id, push_task_payload, watch = nil, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `push_task`."
      end
      # verify the required parameter 'push_task_payload' is set
      if @api_client.config.client_side_validation && push_task_payload.nil?
        raise ArgumentError, "Parameter `push_task_payload` is required when calling `push_task`."
      end

      path = "/2/tasks/{taskID}/push".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params[:watch] = watch unless watch.nil?
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?
      request_options[:timeout] ||= 180000
      request_options[:connect_timeout] ||= 180000

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(push_task_payload)

      new_options = request_options.merge(
        :operation => :"IngestionClient.push_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Pushes records through the Pipeline, directly to an index. You can make the call synchronous by providing the `watch` parameter, for asynchronous calls, you can use the observability endpoints and/or debugger dashboard to see the status of your task. If you want to leverage the [pre-indexing data transformation](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/transform-your-data/), this is the recommended way of ingesting your records. This method is similar to `push`, but requires a `taskID` instead of a `indexName`, which is useful when many `destinations` target the same `indexName`.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param push_task_payload [PushTaskPayload]  (required)
    # @param watch [Boolean] When provided, the push operation will be synchronous and the API will wait for the ingestion to be finished before responding.
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [WatchResponse]
    def push_task(task_id, push_task_payload, watch = nil, request_options = {})
      response = push_task_with_http_info(task_id, push_task_payload, watch, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::WatchResponse")
    end

    # Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param run_source_payload [RunSourcePayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def run_source_with_http_info(source_id, run_source_payload = nil, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `run_source`."
      end

      path = "/1/sources/{sourceID}/run".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(run_source_payload)

      new_options = request_options.merge(
        :operation => :"IngestionClient.run_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Runs all tasks linked to a source, only available for Shopify, BigCommerce and commercetools sources. Creates one run per task.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param run_source_payload [RunSourcePayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RunSourceResponse]
    def run_source(source_id, run_source_payload = nil, request_options = {})
      response = run_source_with_http_info(source_id, run_source_payload, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::RunSourceResponse")
    end

    # Runs a task. You can check the status of task runs with the observability endpoints.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param run_task_payload [RunTaskPayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def run_task_with_http_info(task_id, run_task_payload = nil, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `run_task`."
      end

      path = "/2/tasks/{taskID}/run".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(run_task_payload)

      new_options = request_options.merge(
        :operation => :"IngestionClient.run_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Runs a task. You can check the status of task runs with the observability endpoints.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param run_task_payload [RunTaskPayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RunResponse]
    def run_task(task_id, run_task_payload = nil, request_options = {})
      response = run_task_with_http_info(task_id, run_task_payload, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::RunResponse")
    end

    # Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param run_task_payload [RunTaskPayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def run_task_v1_with_http_info(task_id, run_task_payload = nil, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `run_task_v1`."
      end

      path = "/1/tasks/{taskID}/run".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(run_task_payload)

      new_options = request_options.merge(
        :operation => :"IngestionClient.run_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Runs a task using the v1 endpoint, please use `runTask` instead. You can check the status of task runs with the observability endpoints.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_id [String] Unique identifier of a task. (required)
    # @param run_task_payload [RunTaskPayload]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [RunResponse]
    def run_task_v1(task_id, run_task_payload = nil, request_options = {})
      response = run_task_v1_with_http_info(task_id, run_task_payload, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::RunResponse")
    end

    # Searches for authentication resources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_search [AuthenticationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_authentications_with_http_info(authentication_search, request_options = {})
      # verify the required parameter 'authentication_search' is set
      if @api_client.config.client_side_validation && authentication_search.nil?
        raise ArgumentError, "Parameter `authentication_search` is required when calling `search_authentications`."
      end

      path = "/1/authentications/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(authentication_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_authentications",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for authentication resources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_search [AuthenticationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Authentication>]
    def search_authentications(authentication_search, request_options = {})
      response = search_authentications_with_http_info(authentication_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::Authentication>")
    end

    # Searches for destinations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_search [DestinationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_destinations_with_http_info(destination_search, request_options = {})
      # verify the required parameter 'destination_search' is set
      if @api_client.config.client_side_validation && destination_search.nil?
        raise ArgumentError, "Parameter `destination_search` is required when calling `search_destinations`."
      end

      path = "/1/destinations/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(destination_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_destinations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for destinations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_search [DestinationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Destination>]
    def search_destinations(destination_search, request_options = {})
      response = search_destinations_with_http_info(destination_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::Destination>")
    end

    # Searches for sources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_search [SourceSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_sources_with_http_info(source_search, request_options = {})
      # verify the required parameter 'source_search' is set
      if @api_client.config.client_side_validation && source_search.nil?
        raise ArgumentError, "Parameter `source_search` is required when calling `search_sources`."
      end

      path = "/1/sources/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for sources.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_search [SourceSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Source>]
    def search_sources(source_search, request_options = {})
      response = search_sources_with_http_info(source_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::Source>")
    end

    # Searches for tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_search [TaskSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_tasks_with_http_info(task_search, request_options = {})
      # verify the required parameter 'task_search' is set
      if @api_client.config.client_side_validation && task_search.nil?
        raise ArgumentError, "Parameter `task_search` is required when calling `search_tasks`."
      end

      path = "/2/tasks/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_tasks",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for tasks.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_search [TaskSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Task>]
    def search_tasks(task_search, request_options = {})
      response = search_tasks_with_http_info(task_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::Task>")
    end

    # Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # THIS OPERATION IS DEPRECATED
    # @param task_search [TaskSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_tasks_v1_with_http_info(task_search, request_options = {})
      # verify the required parameter 'task_search' is set
      if @api_client.config.client_side_validation && task_search.nil?
        raise ArgumentError, "Parameter `task_search` is required when calling `search_tasks_v1`."
      end

      path = "/1/tasks/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_tasks_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for tasks using the v1 endpoint, please use `searchTasks` instead.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param task_search [TaskSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<TaskV1>]
    def search_tasks_v1(task_search, request_options = {})
      response = search_tasks_v1_with_http_info(task_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::TaskV1>")
    end

    # Searches for transformations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_search [TransformationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def search_transformations_with_http_info(transformation_search, request_options = {})
      # verify the required parameter 'transformation_search' is set
      if @api_client.config.client_side_validation && transformation_search.nil?
        raise ArgumentError, "Parameter `transformation_search` is required when calling `search_transformations`."
      end

      path = "/1/transformations/search"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(transformation_search)

      new_options = request_options.merge(
        :operation => :"IngestionClient.search_transformations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Searches for transformations.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_search [TransformationSearch]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Array<Transformation>]
    def search_transformations(transformation_search, request_options = {})
      response = search_transformations_with_http_info(transformation_search, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Array<Ingestion::Transformation>")
    end

    # Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def trigger_docker_source_discover_with_http_info(source_id, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `trigger_docker_source_discover`."
      end

      path = "/1/sources/{sourceID}/discover".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?
      request_options[:timeout] ||= 180000
      request_options[:connect_timeout] ||= 180000

      post_body = request_options[:debug_body]

      new_options = request_options.merge(
        :operation => :"IngestionClient.trigger_docker_source_discover",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Triggers a stream-listing request for a source. Triggering stream-listing requests only works with sources with `type: docker` and `imageType: airbyte`.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [WatchResponse]
    def trigger_docker_source_discover(source_id, request_options = {})
      response = trigger_docker_source_discover_with_http_info(source_id, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::WatchResponse")
    end

    # Try a transformation before creating it.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_try [TransformationTry]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def try_transformation_with_http_info(transformation_try, request_options = {})
      # verify the required parameter 'transformation_try' is set
      if @api_client.config.client_side_validation && transformation_try.nil?
        raise ArgumentError, "Parameter `transformation_try` is required when calling `try_transformation`."
      end

      path = "/1/transformations/try"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(transformation_try)

      new_options = request_options.merge(
        :operation => :"IngestionClient.try_transformation",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Try a transformation before creating it.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_try [TransformationTry]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TransformationTryResponse]
    def try_transformation(transformation_try, request_options = {})
      response = try_transformation_with_http_info(transformation_try, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::TransformationTryResponse"
      )
    end

    # Try a transformation before updating it.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param transformation_try [TransformationTry]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def try_transformation_before_update_with_http_info(transformation_id, transformation_try, request_options = {})
      # verify the required parameter 'transformation_id' is set
      if @api_client.config.client_side_validation && transformation_id.nil?
        raise(
          ArgumentError,
          "Parameter `transformation_id` is required when calling `try_transformation_before_update`."
        )
      end
      # verify the required parameter 'transformation_try' is set
      if @api_client.config.client_side_validation && transformation_try.nil?
        raise(
          ArgumentError,
          "Parameter `transformation_try` is required when calling `try_transformation_before_update`."
        )
      end

      path = "/1/transformations/{transformationID}/try".sub(
        "{" + "transformationID" + "}",
        Transport.encode_uri(transformation_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(transformation_try)

      new_options = request_options.merge(
        :operation => :"IngestionClient.try_transformation_before_update",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Try a transformation before updating it.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param transformation_try [TransformationTry]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TransformationTryResponse]
    def try_transformation_before_update(transformation_id, transformation_try, request_options = {})
      response = try_transformation_before_update_with_http_info(transformation_id, transformation_try, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::TransformationTryResponse"
      )
    end

    # Updates an authentication resource.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param authentication_update [AuthenticationUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_authentication_with_http_info(authentication_id, authentication_update, request_options = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        raise ArgumentError, "Parameter `authentication_id` is required when calling `update_authentication`."
      end
      # verify the required parameter 'authentication_update' is set
      if @api_client.config.client_side_validation && authentication_update.nil?
        raise ArgumentError, "Parameter `authentication_update` is required when calling `update_authentication`."
      end

      path = "/1/authentications/{authenticationID}".sub(
        "{" + "authenticationID" + "}",
        Transport.encode_uri(authentication_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(authentication_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Updates an authentication resource.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param authentication_id [String] Unique identifier of an authentication resource. (required)
    # @param authentication_update [AuthenticationUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [AuthenticationUpdateResponse]
    def update_authentication(authentication_id, authentication_update, request_options = {})
      response = update_authentication_with_http_info(authentication_id, authentication_update, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::AuthenticationUpdateResponse"
      )
    end

    # Updates the destination by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param destination_update [DestinationUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_destination_with_http_info(destination_id, destination_update, request_options = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        raise ArgumentError, "Parameter `destination_id` is required when calling `update_destination`."
      end
      # verify the required parameter 'destination_update' is set
      if @api_client.config.client_side_validation && destination_update.nil?
        raise ArgumentError, "Parameter `destination_update` is required when calling `update_destination`."
      end

      path = "/1/destinations/{destinationID}".sub(
        "{" + "destinationID" + "}",
        Transport.encode_uri(destination_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(destination_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Updates the destination by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param destination_id [String] Unique identifier of a destination. (required)
    # @param destination_update [DestinationUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [DestinationUpdateResponse]
    def update_destination(destination_id, destination_update, request_options = {})
      response = update_destination_with_http_info(destination_id, destination_update, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::DestinationUpdateResponse"
      )
    end

    # Updates a source by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param source_update [SourceUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_source_with_http_info(source_id, source_update, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `update_source`."
      end
      # verify the required parameter 'source_update' is set
      if @api_client.config.client_side_validation && source_update.nil?
        raise ArgumentError, "Parameter `source_update` is required when calling `update_source`."
      end

      path = "/1/sources/{sourceID}".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Updates a source by its ID.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param source_update [SourceUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [SourceUpdateResponse]
    def update_source(source_id, source_update, request_options = {})
      response = update_source_with_http_info(source_id, source_update, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::SourceUpdateResponse")
    end

    # Updates a task by its ID.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param task_update [TaskUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_task_with_http_info(task_id, task_update, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `update_task`."
      end
      # verify the required parameter 'task_update' is set
      if @api_client.config.client_side_validation && task_update.nil?
        raise ArgumentError, "Parameter `task_update` is required when calling `update_task`."
      end

      path = "/2/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Updates a task by its ID.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param task_update [TaskUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def update_task(task_id, task_update, request_options = {})
      response = update_task_with_http_info(task_id, task_update, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

    # THIS OPERATION IS DEPRECATED
    # @param task_id [String] Unique identifier of a task. (required)
    # @param task_update [TaskUpdateV1]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_task_v1_with_http_info(task_id, task_update, request_options = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        raise ArgumentError, "Parameter `task_id` is required when calling `update_task_v1`."
      end
      # verify the required parameter 'task_update' is set
      if @api_client.config.client_side_validation && task_update.nil?
        raise ArgumentError, "Parameter `task_update` is required when calling `update_task_v1`."
      end

      path = "/1/tasks/{taskID}".sub("{" + "taskID" + "}", Transport.encode_uri(task_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(task_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_task_v1",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Updates a task by its ID using the v1 endpoint, please use `updateTask` instead.

    # @param task_id [String] Unique identifier of a task. (required)
    # @param task_update [TaskUpdateV1]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TaskUpdateResponse]
    def update_task_v1(task_id, task_update, request_options = {})
      response = update_task_v1_with_http_info(task_id, task_update, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::TaskUpdateResponse")
    end

    # Updates a transformation by its ID.

    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param transformation_create [TransformationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def update_transformation_with_http_info(transformation_id, transformation_create, request_options = {})
      # verify the required parameter 'transformation_id' is set
      if @api_client.config.client_side_validation && transformation_id.nil?
        raise ArgumentError, "Parameter `transformation_id` is required when calling `update_transformation`."
      end
      # verify the required parameter 'transformation_create' is set
      if @api_client.config.client_side_validation && transformation_create.nil?
        raise ArgumentError, "Parameter `transformation_create` is required when calling `update_transformation`."
      end

      path = "/1/transformations/{transformationID}".sub(
        "{" + "transformationID" + "}",
        Transport.encode_uri(transformation_id.to_s)
      )
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(transformation_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.update_transformation",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Updates a transformation by its ID.

    # @param transformation_id [String] Unique identifier of a transformation. (required)
    # @param transformation_create [TransformationCreate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [TransformationUpdateResponse]
    def update_transformation(transformation_id, transformation_create, request_options = {})
      response = update_transformation_with_http_info(transformation_id, transformation_create, request_options)
      @api_client.deserialize(
        response.body,
        request_options[:debug_return_type] || "Ingestion::TransformationUpdateResponse"
      )
    end

    # Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_create [SourceCreate]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def validate_source_with_http_info(source_create = nil, request_options = {})
      path = "/1/sources/validate"
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?
      request_options[:timeout] ||= 180000
      request_options[:connect_timeout] ||= 180000

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source_create)

      new_options = request_options.merge(
        :operation => :"IngestionClient.validate_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Validates a source payload to ensure it can be created and that the data source can be reached by Algolia.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_create [SourceCreate]
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [WatchResponse]
    def validate_source(source_create = nil, request_options = {})
      response = validate_source_with_http_info(source_create, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::WatchResponse")
    end

    # Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param source_update [SourceUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [Http::Response] the response
    def validate_source_before_update_with_http_info(source_id, source_update, request_options = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        raise ArgumentError, "Parameter `source_id` is required when calling `validate_source_before_update`."
      end
      # verify the required parameter 'source_update' is set
      if @api_client.config.client_side_validation && source_update.nil?
        raise ArgumentError, "Parameter `source_update` is required when calling `validate_source_before_update`."
      end

      path = "/1/sources/{sourceID}/validate".sub("{" + "sourceID" + "}", Transport.encode_uri(source_id.to_s))
      query_params = {}
      query_params = query_params.merge(request_options[:query_params]) unless request_options[:query_params].nil?
      header_params = {}
      header_params = header_params.merge(request_options[:header_params]) unless request_options[:header_params].nil?
      request_options[:timeout] ||= 180000
      request_options[:connect_timeout] ||= 180000

      post_body = request_options[:debug_body] || @api_client.object_to_http_body(source_update)

      new_options = request_options.merge(
        :operation => :"IngestionClient.validate_source_before_update",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Validates an update of a source payload to ensure it can be created and that the data source can be reached by Algolia.
    #
    # Required API Key ACLs:
    #   - addObject
    #   - deleteIndex
    #   - editSettings
    # @param source_id [String] Unique identifier of a source. (required)
    # @param source_update [SourceUpdate]  (required)
    # @param request_options: The request options to send along with the query, they will be merged with the transporter base parameters (headers, query params, timeouts, etc.). (optional)
    # @return [WatchResponse]
    def validate_source_before_update(source_id, source_update, request_options = {})
      response = validate_source_before_update_with_http_info(source_id, source_update, request_options)
      @api_client.deserialize(response.body, request_options[:debug_return_type] || "Ingestion::WatchResponse")
    end

  end
end
