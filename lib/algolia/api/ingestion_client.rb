# Code generated by OpenAPI Generator (https://openapi-generator.tech), manual changes will be lost - read more on https://github.com/algolia/api-clients-automation. DO NOT EDIT.

require 'cgi'

module Algolia
  class IngestionClient
    attr_accessor :api_client

    def initialize(config = nil)
      @api_client = Algolia::ApiClient.new(config)
    end

    def self.create(app_id, api_key, region = nil)
      hosts = []
      regions = ['eu', 'us']

      if region.nil? || (region != '' && !regions.include?(region))
        raise "`region` is required and must be one of the following: %s" % regions.join(', ')
      end

      hosts << Transport::StatefulHost.new("data.{region}.algolia.com".sub!('{region}', region), accept: CallType::READ | CallType::WRITE)
      
      config = Algolia::Configuration.new(app_id, api_key, hosts, 'Ingestion')
      create_with_config(config)
    end


    def self.create_with_config(config)
      new(config)
    end

    # Create a authentication.
    # Create a authentication.
    # @param authentication_create [AuthenticationCreate] 
    # @param [Hash] opts the optional parameters
    # @return [AuthenticationCreateResponse]
    def create_authentication(authentication_create, opts = {})
      data, _status_code, _headers = create_authentication_with_http_info(authentication_create, opts)
      data
    end

    # Create a authentication.
    # Create a authentication.
    # @param authentication_create [AuthenticationCreate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AuthenticationCreateResponse, Integer, Hash)>] AuthenticationCreateResponse data, response status code and response headers
    def create_authentication_with_http_info(authentication_create, opts = {})
      # verify the required parameter 'authentication_create' is set
      if @api_client.config.client_side_validation && authentication_create.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_create' when calling IngestionClient.create_authentication"
      end
      path = '/1/authentications'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(authentication_create)

      return_type = opts[:debug_return_type] || 'Ingestion::AuthenticationCreateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.create_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Create a destination.
    # Create a destination.
    # @param destination_create [DestinationCreate] 
    # @param [Hash] opts the optional parameters
    # @return [DestinationCreateResponse]
    def create_destination(destination_create, opts = {})
      data, _status_code, _headers = create_destination_with_http_info(destination_create, opts)
      data
    end

    # Create a destination.
    # Create a destination.
    # @param destination_create [DestinationCreate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DestinationCreateResponse, Integer, Hash)>] DestinationCreateResponse data, response status code and response headers
    def create_destination_with_http_info(destination_create, opts = {})
      # verify the required parameter 'destination_create' is set
      if @api_client.config.client_side_validation && destination_create.nil?
        fail ArgumentError, "Missing the required parameter 'destination_create' when calling IngestionClient.create_destination"
      end
      path = '/1/destinations'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(destination_create)

      return_type = opts[:debug_return_type] || 'Ingestion::DestinationCreateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.create_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Create a source.
    # Create a source.
    # @param source_create [SourceCreate] 
    # @param [Hash] opts the optional parameters
    # @return [SourceCreateResponse]
    def create_source(source_create, opts = {})
      data, _status_code, _headers = create_source_with_http_info(source_create, opts)
      data
    end

    # Create a source.
    # Create a source.
    # @param source_create [SourceCreate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SourceCreateResponse, Integer, Hash)>] SourceCreateResponse data, response status code and response headers
    def create_source_with_http_info(source_create, opts = {})
      # verify the required parameter 'source_create' is set
      if @api_client.config.client_side_validation && source_create.nil?
        fail ArgumentError, "Missing the required parameter 'source_create' when calling IngestionClient.create_source"
      end
      path = '/1/sources'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(source_create)

      return_type = opts[:debug_return_type] || 'Ingestion::SourceCreateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.create_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Create a task.
    # Create a task.
    # @param task_create [TaskCreate] 
    # @param [Hash] opts the optional parameters
    # @return [TaskCreateResponse]
    def create_task(task_create, opts = {})
      data, _status_code, _headers = create_task_with_http_info(task_create, opts)
      data
    end

    # Create a task.
    # Create a task.
    # @param task_create [TaskCreate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskCreateResponse, Integer, Hash)>] TaskCreateResponse data, response status code and response headers
    def create_task_with_http_info(task_create, opts = {})
      # verify the required parameter 'task_create' is set
      if @api_client.config.client_side_validation && task_create.nil?
        fail ArgumentError, "Missing the required parameter 'task_create' when calling IngestionClient.create_task"
      end
      path = '/1/tasks'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(task_create)

      return_type = opts[:debug_return_type] || 'Ingestion::TaskCreateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.create_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Object]
    def custom_delete(path, opts = {})
      data, _status_code, _headers = custom_delete_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_delete_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling IngestionClient.custom_delete"
      end
      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:'parameters'] = opts[:'parameters'] if !opts[:'parameters'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Object'

      new_options = opts.merge(
        :operation => :"IngestionClient.custom_delete",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Object]
    def custom_get(path, opts = {})
      data, _status_code, _headers = custom_get_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_get_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling IngestionClient.custom_get"
      end
      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:'parameters'] = opts[:'parameters'] if !opts[:'parameters'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Object'

      new_options = opts.merge(
        :operation => :"IngestionClient.custom_get",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Object]
    def custom_post(path, opts = {})
      data, _status_code, _headers = custom_post_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_post_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling IngestionClient.custom_post"
      end
      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:'parameters'] = opts[:'parameters'] if !opts[:'parameters'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      return_type = opts[:debug_return_type] || 'Ingestion::Object'

      new_options = opts.merge(
        :operation => :"IngestionClient.custom_post",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Object]
    def custom_put(path, opts = {})
      data, _status_code, _headers = custom_put_with_http_info(path, opts)
      data
    end

    # Send requests to the Algolia REST API.
    # This method allow you to send requests to the Algolia REST API.
    # @param path [String] Path of the endpoint, anything after \&quot;/1\&quot; must be specified.
    # @param [Hash] opts the optional parameters
    # @option opts [Hash<String, Object>] :parameters Query parameters to apply to the current query.
    # @option opts [Object] :body Parameters to send with the custom request.
    # @return [Array<(Object, Integer, Hash)>] Object data, response status code and response headers
    def custom_put_with_http_info(path, opts = {})
      # verify the required parameter 'path' is set
      if @api_client.config.client_side_validation && path.nil?
        fail ArgumentError, "Missing the required parameter 'path' when calling IngestionClient.custom_put"
      end
      path = '/1{path}'.sub('{' + 'path' + '}', CGI.escape(path.to_s))
      query_params = opts[:query_params] || {}
      query_params[:'parameters'] = opts[:'parameters'] if !opts[:'parameters'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      return_type = opts[:debug_return_type] || 'Ingestion::Object'

      new_options = opts.merge(
        :operation => :"IngestionClient.custom_put",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Delete a authentication.
    # Soft delete the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param [Hash] opts the optional parameters
    # @return [DeleteResponse]
    def delete_authentication(authentication_id, opts = {})
      data, _status_code, _headers = delete_authentication_with_http_info(authentication_id, opts)
      data
    end

    # Delete a authentication.
    # Soft delete the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteResponse, Integer, Hash)>] DeleteResponse data, response status code and response headers
    def delete_authentication_with_http_info(authentication_id, opts = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_id' when calling IngestionClient.delete_authentication"
      end
      path = '/1/authentications/{authenticationID}'.sub('{' + 'authenticationID' + '}', CGI.escape(authentication_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DeleteResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.delete_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a destination.
    # Soft delete the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param [Hash] opts the optional parameters
    # @return [DeleteResponse]
    def delete_destination(destination_id, opts = {})
      data, _status_code, _headers = delete_destination_with_http_info(destination_id, opts)
      data
    end

    # Delete a destination.
    # Soft delete the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteResponse, Integer, Hash)>] DeleteResponse data, response status code and response headers
    def delete_destination_with_http_info(destination_id, opts = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        fail ArgumentError, "Missing the required parameter 'destination_id' when calling IngestionClient.delete_destination"
      end
      path = '/1/destinations/{destinationID}'.sub('{' + 'destinationID' + '}', CGI.escape(destination_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DeleteResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.delete_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a source.
    # Soft delete the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [DeleteResponse]
    def delete_source(source_id, opts = {})
      data, _status_code, _headers = delete_source_with_http_info(source_id, opts)
      data
    end

    # Delete a source.
    # Soft delete the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteResponse, Integer, Hash)>] DeleteResponse data, response status code and response headers
    def delete_source_with_http_info(source_id, opts = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        fail ArgumentError, "Missing the required parameter 'source_id' when calling IngestionClient.delete_source"
      end
      path = '/1/sources/{sourceID}'.sub('{' + 'sourceID' + '}', CGI.escape(source_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DeleteResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.delete_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Delete a task.
    # Soft delete the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [DeleteResponse]
    def delete_task(task_id, opts = {})
      data, _status_code, _headers = delete_task_with_http_info(task_id, opts)
      data
    end

    # Delete a task.
    # Soft delete the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DeleteResponse, Integer, Hash)>] DeleteResponse data, response status code and response headers
    def delete_task_with_http_info(task_id, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.delete_task"
      end
      path = '/1/tasks/{taskID}'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DeleteResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.delete_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:DELETE, path, new_options)
    end

    # Disable a task.
    # Disable the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [TaskUpdateResponse]
    def disable_task(task_id, opts = {})
      data, _status_code, _headers = disable_task_with_http_info(task_id, opts)
      data
    end

    # Disable a task.
    # Disable the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskUpdateResponse, Integer, Hash)>] TaskUpdateResponse data, response status code and response headers
    def disable_task_with_http_info(task_id, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.disable_task"
      end
      path = '/1/tasks/{taskID}/disable'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::TaskUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.disable_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Enable a task.
    # Enable the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [TaskUpdateResponse]
    def enable_task(task_id, opts = {})
      data, _status_code, _headers = enable_task_with_http_info(task_id, opts)
      data
    end

    # Enable a task.
    # Enable the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskUpdateResponse, Integer, Hash)>] TaskUpdateResponse data, response status code and response headers
    def enable_task_with_http_info(task_id, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.enable_task"
      end
      path = '/1/tasks/{taskID}/enable'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::TaskUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.enable_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PUT, path, new_options)
    end

    # Get a authentication.
    # Get the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param [Hash] opts the optional parameters
    # @return [Authentication]
    def get_authentication(authentication_id, opts = {})
      data, _status_code, _headers = get_authentication_with_http_info(authentication_id, opts)
      data
    end

    # Get a authentication.
    # Get the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Authentication, Integer, Hash)>] Authentication data, response status code and response headers
    def get_authentication_with_http_info(authentication_id, opts = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_id' when calling IngestionClient.get_authentication"
      end
      path = '/1/authentications/{authenticationID}'.sub('{' + 'authenticationID' + '}', CGI.escape(authentication_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Authentication'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of authentications.
    # Get a list of authentications for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<AuthenticationType>] :type The type of the authentications to retrieve.
    # @option opts [Array<PlatformWithNone>] :platform The platform of the authentications to retrieve.
    # @option opts [AuthenticationSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [ListAuthenticationsResponse]
    def get_authentications(opts = {})
      data, _status_code, _headers = get_authentications_with_http_info(opts)
      data
    end

    # Get a list of authentications.
    # Get a list of authentications for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<AuthenticationType>] :type The type of the authentications to retrieve.
    # @option opts [Array<PlatformWithNone>] :platform The platform of the authentications to retrieve.
    # @option opts [AuthenticationSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [Array<(ListAuthenticationsResponse, Integer, Hash)>] ListAuthenticationsResponse data, response status code and response headers
    def get_authentications_with_http_info(opts = {})
      path = '/1/authentications'
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'type'] = @api_client.build_collection_param(opts[:'type'], :csv) if !opts[:'type'].nil?
      query_params[:'platform'] = @api_client.build_collection_param(opts[:'platform'], :csv) if !opts[:'platform'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::ListAuthenticationsResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_authentications",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a destination.
    # Get the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param [Hash] opts the optional parameters
    # @return [Destination]
    def get_destination(destination_id, opts = {})
      data, _status_code, _headers = get_destination_with_http_info(destination_id, opts)
      data
    end

    # Get a destination.
    # Get the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Destination, Integer, Hash)>] Destination data, response status code and response headers
    def get_destination_with_http_info(destination_id, opts = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        fail ArgumentError, "Missing the required parameter 'destination_id' when calling IngestionClient.get_destination"
      end
      path = '/1/destinations/{destinationID}'.sub('{' + 'destinationID' + '}', CGI.escape(destination_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Destination'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of destinations.
    # Get a list of destinations for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<DestinationType>] :type The type of the destinations to retrive.
    # @option opts [Array<String>] :authentication_id The authenticationIDs of the destinations to retrive.
    # @option opts [DestinationSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [ListDestinationsResponse]
    def get_destinations(opts = {})
      data, _status_code, _headers = get_destinations_with_http_info(opts)
      data
    end

    # Get a list of destinations.
    # Get a list of destinations for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<DestinationType>] :type The type of the destinations to retrive.
    # @option opts [Array<String>] :authentication_id The authenticationIDs of the destinations to retrive.
    # @option opts [DestinationSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [Array<(ListDestinationsResponse, Integer, Hash)>] ListDestinationsResponse data, response status code and response headers
    def get_destinations_with_http_info(opts = {})
      path = '/1/destinations'
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'type'] = @api_client.build_collection_param(opts[:'type'], :csv) if !opts[:'type'].nil?
      query_params[:'authenticationID'] = @api_client.build_collection_param(opts[:'authentication_id'], :csv) if !opts[:'authentication_id'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::ListDestinationsResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_destinations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Retrieve a stream listing.
    # Retrieve a stream listing for a given Singer specification compatible docker type source ID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [DockerSourceStreams]
    def get_docker_source_streams(source_id, opts = {})
      data, _status_code, _headers = get_docker_source_streams_with_http_info(source_id, opts)
      data
    end

    # Retrieve a stream listing.
    # Retrieve a stream listing for a given Singer specification compatible docker type source ID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DockerSourceStreams, Integer, Hash)>] DockerSourceStreams data, response status code and response headers
    def get_docker_source_streams_with_http_info(source_id, opts = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        fail ArgumentError, "Missing the required parameter 'source_id' when calling IngestionClient.get_docker_source_streams"
      end
      path = '/1/sources/{sourceID}/discover'.sub('{' + 'sourceID' + '}', CGI.escape(source_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DockerSourceStreams'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_docker_source_streams",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get an event.
    # Get a single event for a specific runID.
    # @param run_id [String] The run UUID.
    # @param event_id [String] The event UUID.
    # @param [Hash] opts the optional parameters
    # @return [Event]
    def get_event(run_id, event_id, opts = {})
      data, _status_code, _headers = get_event_with_http_info(run_id, event_id, opts)
      data
    end

    # Get an event.
    # Get a single event for a specific runID.
    # @param run_id [String] The run UUID.
    # @param event_id [String] The event UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Event, Integer, Hash)>] Event data, response status code and response headers
    def get_event_with_http_info(run_id, event_id, opts = {})
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        fail ArgumentError, "Missing the required parameter 'run_id' when calling IngestionClient.get_event"
      end
      # verify the required parameter 'event_id' is set
      if @api_client.config.client_side_validation && event_id.nil?
        fail ArgumentError, "Missing the required parameter 'event_id' when calling IngestionClient.get_event"
      end
      path = '/1/runs/{runID}/events/{eventID}'.sub('{' + 'runID' + '}', CGI.escape(run_id.to_s)).sub('{' + 'eventID' + '}', CGI.escape(event_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Event'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_event",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of events.
    # Get a list of events associated to the given runID, for the given query parameters.
    # @param run_id [String] The run UUID.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<EventStatus>] :status Filter the status of the events.
    # @option opts [Array<EventType>] :type Filter the type of the events.
    # @option opts [EventSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @option opts [String] :start_date The start date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39;-3 hours if omitted.
    # @option opts [String] :end_date The end date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39; days if omitted.
    # @return [ListEventsResponse]
    def get_events(run_id, opts = {})
      data, _status_code, _headers = get_events_with_http_info(run_id, opts)
      data
    end

    # Get a list of events.
    # Get a list of events associated to the given runID, for the given query parameters.
    # @param run_id [String] The run UUID.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<EventStatus>] :status Filter the status of the events.
    # @option opts [Array<EventType>] :type Filter the type of the events.
    # @option opts [EventSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @option opts [String] :start_date The start date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39;-3 hours if omitted.
    # @option opts [String] :end_date The end date (in RFC3339 format) of the events fetching window. Defaults to &#39;now&#39; days if omitted.
    # @return [Array<(ListEventsResponse, Integer, Hash)>] ListEventsResponse data, response status code and response headers
    def get_events_with_http_info(run_id, opts = {})
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        fail ArgumentError, "Missing the required parameter 'run_id' when calling IngestionClient.get_events"
      end
      path = '/1/runs/{runID}/events'.sub('{' + 'runID' + '}', CGI.escape(run_id.to_s))
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'status'] = @api_client.build_collection_param(opts[:'status'], :multi) if !opts[:'status'].nil?
      query_params[:'type'] = @api_client.build_collection_param(opts[:'type'], :multi) if !opts[:'type'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::ListEventsResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_events",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a run.
    # Get a single run for the given ID.
    # @param run_id [String] The run UUID.
    # @param [Hash] opts the optional parameters
    # @return [Run]
    def get_run(run_id, opts = {})
      data, _status_code, _headers = get_run_with_http_info(run_id, opts)
      data
    end

    # Get a run.
    # Get a single run for the given ID.
    # @param run_id [String] The run UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Run, Integer, Hash)>] Run data, response status code and response headers
    def get_run_with_http_info(run_id, opts = {})
      # verify the required parameter 'run_id' is set
      if @api_client.config.client_side_validation && run_id.nil?
        fail ArgumentError, "Missing the required parameter 'run_id' when calling IngestionClient.get_run"
      end
      path = '/1/runs/{runID}'.sub('{' + 'runID' + '}', CGI.escape(run_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Run'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_run",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of runs.
    # Get a list of runs for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<RunStatus>] :status Filter the status of the runs.
    # @option opts [String] :task_id Filter by taskID.
    # @option opts [RunSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @option opts [String] :start_date The start date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39;-7 days if omitted.
    # @option opts [String] :end_date The end date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39; days if omitted.
    # @return [RunListResponse]
    def get_runs(opts = {})
      data, _status_code, _headers = get_runs_with_http_info(opts)
      data
    end

    # Get a list of runs.
    # Get a list of runs for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<RunStatus>] :status Filter the status of the runs.
    # @option opts [String] :task_id Filter by taskID.
    # @option opts [RunSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @option opts [String] :start_date The start date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39;-7 days if omitted.
    # @option opts [String] :end_date The end date (in RFC3339 format) of the runs fetching window. Defaults to &#39;now&#39; days if omitted.
    # @return [Array<(RunListResponse, Integer, Hash)>] RunListResponse data, response status code and response headers
    def get_runs_with_http_info(opts = {})
      path = '/1/runs'
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'status'] = @api_client.build_collection_param(opts[:'status'], :multi) if !opts[:'status'].nil?
      query_params[:'taskID'] = opts[:'task_id'] if !opts[:'task_id'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      query_params[:'startDate'] = opts[:'start_date'] if !opts[:'start_date'].nil?
      query_params[:'endDate'] = opts[:'end_date'] if !opts[:'end_date'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::RunListResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_runs",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a source.
    # Get the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [Source]
    def get_source(source_id, opts = {})
      data, _status_code, _headers = get_source_with_http_info(source_id, opts)
      data
    end

    # Get a source.
    # Get the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Source, Integer, Hash)>] Source data, response status code and response headers
    def get_source_with_http_info(source_id, opts = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        fail ArgumentError, "Missing the required parameter 'source_id' when calling IngestionClient.get_source"
      end
      path = '/1/sources/{sourceID}'.sub('{' + 'sourceID' + '}', CGI.escape(source_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Source'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of sources.
    # Get a list of sources for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<SourceType>] :type The type of the sources to retrieve.
    # @option opts [Array<String>] :authentication_id The authenticationIDs of the sources to retrieve. &#39;none&#39; returns sources that doesn&#39;t have an authentication. 
    # @option opts [SourceSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [ListSourcesResponse]
    def get_sources(opts = {})
      data, _status_code, _headers = get_sources_with_http_info(opts)
      data
    end

    # Get a list of sources.
    # Get a list of sources for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<SourceType>] :type The type of the sources to retrieve.
    # @option opts [Array<String>] :authentication_id The authenticationIDs of the sources to retrieve. &#39;none&#39; returns sources that doesn&#39;t have an authentication. 
    # @option opts [SourceSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [Array<(ListSourcesResponse, Integer, Hash)>] ListSourcesResponse data, response status code and response headers
    def get_sources_with_http_info(opts = {})
      path = '/1/sources'
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'type'] = @api_client.build_collection_param(opts[:'type'], :csv) if !opts[:'type'].nil?
      query_params[:'authenticationID'] = @api_client.build_collection_param(opts[:'authentication_id'], :csv) if !opts[:'authentication_id'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::ListSourcesResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a task.
    # Get the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Task]
    def get_task(task_id, opts = {})
      data, _status_code, _headers = get_task_with_http_info(task_id, opts)
      data
    end

    # Get a task.
    # Get the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Task, Integer, Hash)>] Task data, response status code and response headers
    def get_task_with_http_info(task_id, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.get_task"
      end
      path = '/1/tasks/{taskID}'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::Task'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Get a list of tasks.
    # Get a list of tasks for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<ActionType>] :action The action of the tasks to retrieve.
    # @option opts [Boolean] :enabled Whether the task is enabled or not.
    # @option opts [Array<String>] :source_id The sourceIDs of the tasks to retrive.
    # @option opts [Array<String>] :destination_id The destinationIDs of the tasks to retrive.
    # @option opts [Array<TriggerType>] :trigger_type The trigger type of the task.
    # @option opts [TaskSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [ListTasksResponse]
    def get_tasks(opts = {})
      data, _status_code, _headers = get_tasks_with_http_info(opts)
      data
    end

    # Get a list of tasks.
    # Get a list of tasks for the given query parameters, with pagination details.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :items_per_page The number of items per page to return.
    # @option opts [Integer] :page The page number to fetch, starting at 1.
    # @option opts [Array<ActionType>] :action The action of the tasks to retrieve.
    # @option opts [Boolean] :enabled Whether the task is enabled or not.
    # @option opts [Array<String>] :source_id The sourceIDs of the tasks to retrive.
    # @option opts [Array<String>] :destination_id The destinationIDs of the tasks to retrive.
    # @option opts [Array<TriggerType>] :trigger_type The trigger type of the task.
    # @option opts [TaskSortKeys] :sort The key by which the list should be sorted.
    # @option opts [OrderKeys] :order The order of the returned list.
    # @return [Array<(ListTasksResponse, Integer, Hash)>] ListTasksResponse data, response status code and response headers
    def get_tasks_with_http_info(opts = {})
      path = '/1/tasks'
      query_params = opts[:query_params] || {}
      query_params[:'itemsPerPage'] = opts[:'items_per_page'] if !opts[:'items_per_page'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'action'] = @api_client.build_collection_param(opts[:'action'], :csv) if !opts[:'action'].nil?
      query_params[:'enabled'] = opts[:'enabled'] if !opts[:'enabled'].nil?
      query_params[:'sourceID'] = @api_client.build_collection_param(opts[:'source_id'], :csv) if !opts[:'source_id'].nil?
      query_params[:'destinationID'] = @api_client.build_collection_param(opts[:'destination_id'], :csv) if !opts[:'destination_id'].nil?
      query_params[:'triggerType'] = @api_client.build_collection_param(opts[:'trigger_type'], :csv) if !opts[:'trigger_type'].nil?
      query_params[:'sort'] = opts[:'sort'] if !opts[:'sort'].nil?
      query_params[:'order'] = opts[:'order'] if !opts[:'order'].nil?
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::ListTasksResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.get_tasks",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:GET, path, new_options)
    end

    # Run a task.
    # Run the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [RunResponse]
    def run_task(task_id, opts = {})
      data, _status_code, _headers = run_task_with_http_info(task_id, opts)
      data
    end

    # Run a task.
    # Run the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(RunResponse, Integer, Hash)>] RunResponse data, response status code and response headers
    def run_task_with_http_info(task_id, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.run_task"
      end
      path = '/1/tasks/{taskID}/run'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::RunResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.run_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search among authentications.
    # Search among authentications with a defined set of parameters.
    # @param authentication_search [AuthenticationSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<Authentication>]
    def search_authentications(authentication_search, opts = {})
      data, _status_code, _headers = search_authentications_with_http_info(authentication_search, opts)
      data
    end

    # Search among authentications.
    # Search among authentications with a defined set of parameters.
    # @param authentication_search [AuthenticationSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Authentication>, Integer, Hash)>] Array<Authentication> data, response status code and response headers
    def search_authentications_with_http_info(authentication_search, opts = {})
      # verify the required parameter 'authentication_search' is set
      if @api_client.config.client_side_validation && authentication_search.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_search' when calling IngestionClient.search_authentications"
      end
      path = '/1/authentications/search'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(authentication_search)

      return_type = opts[:debug_return_type] || 'Ingestion::Array<Authentication>'

      new_options = opts.merge(
        :operation => :"IngestionClient.search_authentications",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search among destinations.
    # Search among destinations with a defined set of parameters.
    # @param destination_search [DestinationSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<Destination>]
    def search_destinations(destination_search, opts = {})
      data, _status_code, _headers = search_destinations_with_http_info(destination_search, opts)
      data
    end

    # Search among destinations.
    # Search among destinations with a defined set of parameters.
    # @param destination_search [DestinationSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Destination>, Integer, Hash)>] Array<Destination> data, response status code and response headers
    def search_destinations_with_http_info(destination_search, opts = {})
      # verify the required parameter 'destination_search' is set
      if @api_client.config.client_side_validation && destination_search.nil?
        fail ArgumentError, "Missing the required parameter 'destination_search' when calling IngestionClient.search_destinations"
      end
      path = '/1/destinations/search'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(destination_search)

      return_type = opts[:debug_return_type] || 'Ingestion::Array<Destination>'

      new_options = opts.merge(
        :operation => :"IngestionClient.search_destinations",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search among sources.
    # Search among sources with a defined set of parameters.
    # @param source_search [SourceSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<Source>]
    def search_sources(source_search, opts = {})
      data, _status_code, _headers = search_sources_with_http_info(source_search, opts)
      data
    end

    # Search among sources.
    # Search among sources with a defined set of parameters.
    # @param source_search [SourceSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Source>, Integer, Hash)>] Array<Source> data, response status code and response headers
    def search_sources_with_http_info(source_search, opts = {})
      # verify the required parameter 'source_search' is set
      if @api_client.config.client_side_validation && source_search.nil?
        fail ArgumentError, "Missing the required parameter 'source_search' when calling IngestionClient.search_sources"
      end
      path = '/1/sources/search'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(source_search)

      return_type = opts[:debug_return_type] || 'Ingestion::Array<Source>'

      new_options = opts.merge(
        :operation => :"IngestionClient.search_sources",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Search among tasks.
    # Search among tasks with a defined set of parameters.
    # @param task_search [TaskSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<Task>]
    def search_tasks(task_search, opts = {})
      data, _status_code, _headers = search_tasks_with_http_info(task_search, opts)
      data
    end

    # Search among tasks.
    # Search among tasks with a defined set of parameters.
    # @param task_search [TaskSearch] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Task>, Integer, Hash)>] Array<Task> data, response status code and response headers
    def search_tasks_with_http_info(task_search, opts = {})
      # verify the required parameter 'task_search' is set
      if @api_client.config.client_side_validation && task_search.nil?
        fail ArgumentError, "Missing the required parameter 'task_search' when calling IngestionClient.search_tasks"
      end
      path = '/1/tasks/search'
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(task_search)

      return_type = opts[:debug_return_type] || 'Ingestion::Array<Task>'

      new_options = opts.merge(
        :operation => :"IngestionClient.search_tasks",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Trigger a stream listing request.
    # Trigger a stream listing request for a Singer specification compatible docker type source.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [DockerSourceDiscover]
    def trigger_docker_source_discover(source_id, opts = {})
      data, _status_code, _headers = trigger_docker_source_discover_with_http_info(source_id, opts)
      data
    end

    # Trigger a stream listing request.
    # Trigger a stream listing request for a Singer specification compatible docker type source.
    # @param source_id [String] The source UUID.
    # @param [Hash] opts the optional parameters
    # @return [Array<(DockerSourceDiscover, Integer, Hash)>] DockerSourceDiscover data, response status code and response headers
    def trigger_docker_source_discover_with_http_info(source_id, opts = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        fail ArgumentError, "Missing the required parameter 'source_id' when calling IngestionClient.trigger_docker_source_discover"
      end
      path = '/1/sources/{sourceID}/discover'.sub('{' + 'sourceID' + '}', CGI.escape(source_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body]

      return_type = opts[:debug_return_type] || 'Ingestion::DockerSourceDiscover'

      new_options = opts.merge(
        :operation => :"IngestionClient.trigger_docker_source_discover",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:POST, path, new_options)
    end

    # Update a authentication.
    # Update the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param authentication_update [AuthenticationUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [AuthenticationUpdateResponse]
    def update_authentication(authentication_id, authentication_update, opts = {})
      data, _status_code, _headers = update_authentication_with_http_info(authentication_id, authentication_update, opts)
      data
    end

    # Update a authentication.
    # Update the authentication of the given authenticationID.
    # @param authentication_id [String] The authentication UUID.
    # @param authentication_update [AuthenticationUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(AuthenticationUpdateResponse, Integer, Hash)>] AuthenticationUpdateResponse data, response status code and response headers
    def update_authentication_with_http_info(authentication_id, authentication_update, opts = {})
      # verify the required parameter 'authentication_id' is set
      if @api_client.config.client_side_validation && authentication_id.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_id' when calling IngestionClient.update_authentication"
      end
      # verify the required parameter 'authentication_update' is set
      if @api_client.config.client_side_validation && authentication_update.nil?
        fail ArgumentError, "Missing the required parameter 'authentication_update' when calling IngestionClient.update_authentication"
      end
      path = '/1/authentications/{authenticationID}'.sub('{' + 'authenticationID' + '}', CGI.escape(authentication_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(authentication_update)

      return_type = opts[:debug_return_type] || 'Ingestion::AuthenticationUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.update_authentication",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Update a destination.
    # Update the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param destination_update [DestinationUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [DestinationUpdateResponse]
    def update_destination(destination_id, destination_update, opts = {})
      data, _status_code, _headers = update_destination_with_http_info(destination_id, destination_update, opts)
      data
    end

    # Update a destination.
    # Update the destination of the given destinationID.
    # @param destination_id [String] The destination UUID.
    # @param destination_update [DestinationUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(DestinationUpdateResponse, Integer, Hash)>] DestinationUpdateResponse data, response status code and response headers
    def update_destination_with_http_info(destination_id, destination_update, opts = {})
      # verify the required parameter 'destination_id' is set
      if @api_client.config.client_side_validation && destination_id.nil?
        fail ArgumentError, "Missing the required parameter 'destination_id' when calling IngestionClient.update_destination"
      end
      # verify the required parameter 'destination_update' is set
      if @api_client.config.client_side_validation && destination_update.nil?
        fail ArgumentError, "Missing the required parameter 'destination_update' when calling IngestionClient.update_destination"
      end
      path = '/1/destinations/{destinationID}'.sub('{' + 'destinationID' + '}', CGI.escape(destination_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(destination_update)

      return_type = opts[:debug_return_type] || 'Ingestion::DestinationUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.update_destination",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Update a source.
    # Update the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param source_update [SourceUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [SourceUpdateResponse]
    def update_source(source_id, source_update, opts = {})
      data, _status_code, _headers = update_source_with_http_info(source_id, source_update, opts)
      data
    end

    # Update a source.
    # Update the source of the given sourceID.
    # @param source_id [String] The source UUID.
    # @param source_update [SourceUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(SourceUpdateResponse, Integer, Hash)>] SourceUpdateResponse data, response status code and response headers
    def update_source_with_http_info(source_id, source_update, opts = {})
      # verify the required parameter 'source_id' is set
      if @api_client.config.client_side_validation && source_id.nil?
        fail ArgumentError, "Missing the required parameter 'source_id' when calling IngestionClient.update_source"
      end
      # verify the required parameter 'source_update' is set
      if @api_client.config.client_side_validation && source_update.nil?
        fail ArgumentError, "Missing the required parameter 'source_update' when calling IngestionClient.update_source"
      end
      path = '/1/sources/{sourceID}'.sub('{' + 'sourceID' + '}', CGI.escape(source_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(source_update)

      return_type = opts[:debug_return_type] || 'Ingestion::SourceUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.update_source",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end

    # Update a task.
    # Update the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param task_update [TaskUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [TaskUpdateResponse]
    def update_task(task_id, task_update, opts = {})
      data, _status_code, _headers = update_task_with_http_info(task_id, task_update, opts)
      data
    end

    # Update a task.
    # Update the task of the given taskID.
    # @param task_id [String] The task UUID.
    # @param task_update [TaskUpdate] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(TaskUpdateResponse, Integer, Hash)>] TaskUpdateResponse data, response status code and response headers
    def update_task_with_http_info(task_id, task_update, opts = {})
      # verify the required parameter 'task_id' is set
      if @api_client.config.client_side_validation && task_id.nil?
        fail ArgumentError, "Missing the required parameter 'task_id' when calling IngestionClient.update_task"
      end
      # verify the required parameter 'task_update' is set
      if @api_client.config.client_side_validation && task_update.nil?
        fail ArgumentError, "Missing the required parameter 'task_update' when calling IngestionClient.update_task"
      end
      path = '/1/tasks/{taskID}'.sub('{' + 'taskID' + '}', CGI.escape(task_id.to_s))
      query_params = opts[:query_params] || {}
      header_params = opts[:header_params] || {}

      post_body = opts[:debug_body] || @api_client.object_to_http_body(task_update)

      return_type = opts[:debug_return_type] || 'Ingestion::TaskUpdateResponse'

      new_options = opts.merge(
        :operation => :"IngestionClient.update_task",
        :header_params => header_params,
        :query_params => query_params,
        :body => post_body,
        :return_type => return_type,
        :use_read_transporter => false
      )

      @api_client.call_api(:PATCH, path, new_options)
    end
  end
end
